"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/constants.js
var require_constants = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.constants = void 0;
    exports2.constants = {
      O_RDONLY: 0,
      O_WRONLY: 1,
      O_RDWR: 2,
      S_IFMT: 61440,
      S_IFREG: 32768,
      S_IFDIR: 16384,
      S_IFCHR: 8192,
      S_IFBLK: 24576,
      S_IFIFO: 4096,
      S_IFLNK: 40960,
      S_IFSOCK: 49152,
      O_CREAT: 64,
      O_EXCL: 128,
      O_NOCTTY: 256,
      O_TRUNC: 512,
      O_APPEND: 1024,
      O_DIRECTORY: 65536,
      O_NOATIME: 262144,
      O_NOFOLLOW: 131072,
      O_SYNC: 1052672,
      O_DIRECT: 16384,
      O_NONBLOCK: 2048,
      S_IRWXU: 448,
      S_IRUSR: 256,
      S_IWUSR: 128,
      S_IXUSR: 64,
      S_IRWXG: 56,
      S_IRGRP: 32,
      S_IWGRP: 16,
      S_IXGRP: 8,
      S_IRWXO: 7,
      S_IROTH: 4,
      S_IWOTH: 2,
      S_IXOTH: 1,
      F_OK: 0,
      R_OK: 4,
      W_OK: 2,
      X_OK: 1,
      UV_FS_SYMLINK_DIR: 1,
      UV_FS_SYMLINK_JUNCTION: 2,
      UV_FS_COPYFILE_EXCL: 1,
      UV_FS_COPYFILE_FICLONE: 2,
      UV_FS_COPYFILE_FICLONE_FORCE: 4,
      COPYFILE_EXCL: 1,
      COPYFILE_FICLONE: 2,
      COPYFILE_FICLONE_FORCE: 4
    };
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/getBigInt.js
var require_getBigInt = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/getBigInt.js"(exports2) {
    if (typeof BigInt === "function") exports2.default = BigInt;
    else
      exports2.default = function BigIntNotSupported() {
        throw new Error("BigInt is not supported in this environment.");
      };
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/Stats.js
var require_Stats = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/Stats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Stats = void 0;
    var constants_1 = require_constants();
    var getBigInt_1 = require_getBigInt();
    var S_IFMT = constants_1.constants.S_IFMT;
    var S_IFDIR = constants_1.constants.S_IFDIR;
    var S_IFREG = constants_1.constants.S_IFREG;
    var S_IFBLK = constants_1.constants.S_IFBLK;
    var S_IFCHR = constants_1.constants.S_IFCHR;
    var S_IFLNK = constants_1.constants.S_IFLNK;
    var S_IFIFO = constants_1.constants.S_IFIFO;
    var S_IFSOCK = constants_1.constants.S_IFSOCK;
    var Stats = (
      /** @class */
      function() {
        function Stats2() {
        }
        Stats2.build = function(node, bigint) {
          if (bigint === void 0) {
            bigint = false;
          }
          var stats = new Stats2();
          var uid = node.uid, gid = node.gid, atime = node.atime, mtime = node.mtime, ctime = node.ctime;
          var getStatNumber = !bigint ? function(number) {
            return number;
          } : getBigInt_1.default;
          stats.uid = getStatNumber(uid);
          stats.gid = getStatNumber(gid);
          stats.rdev = getStatNumber(0);
          stats.blksize = getStatNumber(4096);
          stats.ino = getStatNumber(node.ino);
          stats.size = getStatNumber(node.getSize());
          stats.blocks = getStatNumber(1);
          stats.atime = atime;
          stats.mtime = mtime;
          stats.ctime = ctime;
          stats.birthtime = ctime;
          stats.atimeMs = getStatNumber(atime.getTime());
          stats.mtimeMs = getStatNumber(mtime.getTime());
          var ctimeMs = getStatNumber(ctime.getTime());
          stats.ctimeMs = ctimeMs;
          stats.birthtimeMs = ctimeMs;
          stats.dev = getStatNumber(0);
          stats.mode = getStatNumber(node.mode);
          stats.nlink = getStatNumber(node.nlink);
          return stats;
        };
        Stats2.prototype._checkModeProperty = function(property) {
          return (Number(this.mode) & S_IFMT) === property;
        };
        Stats2.prototype.isDirectory = function() {
          return this._checkModeProperty(S_IFDIR);
        };
        Stats2.prototype.isFile = function() {
          return this._checkModeProperty(S_IFREG);
        };
        Stats2.prototype.isBlockDevice = function() {
          return this._checkModeProperty(S_IFBLK);
        };
        Stats2.prototype.isCharacterDevice = function() {
          return this._checkModeProperty(S_IFCHR);
        };
        Stats2.prototype.isSymbolicLink = function() {
          return this._checkModeProperty(S_IFLNK);
        };
        Stats2.prototype.isFIFO = function() {
          return this._checkModeProperty(S_IFIFO);
        };
        Stats2.prototype.isSocket = function() {
          return this._checkModeProperty(S_IFSOCK);
        };
        return Stats2;
      }()
    );
    exports2.Stats = Stats;
    exports2.default = Stats;
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/internal/buffer.js
var require_buffer = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/internal/buffer.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bufferFrom = exports2.bufferAllocUnsafe = exports2.Buffer = void 0;
    var buffer_1 = require("buffer");
    Object.defineProperty(exports2, "Buffer", { enumerable: true, get: function() {
      return buffer_1.Buffer;
    } });
    function bufferV0P12Ponyfill(arg0) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray([void 0, arg0], args, false)))();
    }
    var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
    exports2.bufferAllocUnsafe = bufferAllocUnsafe;
    var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
    exports2.bufferFrom = bufferFrom;
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/internal/errors.js
var require_errors = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/internal/errors.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.E = exports2.AssertionError = exports2.message = exports2.RangeError = exports2.TypeError = exports2.Error = void 0;
    var assert = require("assert");
    var util = require("util");
    var kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
    var messages = {};
    function makeNodeError(Base) {
      return (
        /** @class */
        function(_super) {
          __extends(NodeError, _super);
          function NodeError(key) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              args[_i - 1] = arguments[_i];
            }
            var _this = _super.call(this, message(key, args)) || this;
            _this.code = key;
            _this[kCode] = key;
            _this.name = "".concat(_super.prototype.name, " [").concat(_this[kCode], "]");
            return _this;
          }
          return NodeError;
        }(Base)
      );
    }
    var g = typeof globalThis !== "undefined" ? globalThis : global;
    var AssertionError = (
      /** @class */
      function(_super) {
        __extends(AssertionError2, _super);
        function AssertionError2(options) {
          var _this = this;
          if (typeof options !== "object" || options === null) {
            throw new exports2.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
          }
          if (options.message) {
            _this = _super.call(this, options.message) || this;
          } else {
            _this = _super.call(this, "".concat(util.inspect(options.actual).slice(0, 128), " ") + "".concat(options.operator, " ").concat(util.inspect(options.expected).slice(0, 128))) || this;
          }
          _this.generatedMessage = !options.message;
          _this.name = "AssertionError [ERR_ASSERTION]";
          _this.code = "ERR_ASSERTION";
          _this.actual = options.actual;
          _this.expected = options.expected;
          _this.operator = options.operator;
          exports2.Error.captureStackTrace(_this, options.stackStartFunction);
          return _this;
        }
        return AssertionError2;
      }(g.Error)
    );
    exports2.AssertionError = AssertionError;
    function message(key, args) {
      assert.strictEqual(typeof key, "string");
      var msg = messages[key];
      assert(msg, "An invalid error message key was used: ".concat(key, "."));
      var fmt;
      if (typeof msg === "function") {
        fmt = msg;
      } else {
        fmt = util.format;
        if (args === void 0 || args.length === 0)
          return msg;
        args.unshift(msg);
      }
      return String(fmt.apply(null, args));
    }
    exports2.message = message;
    function E(sym, val) {
      messages[sym] = typeof val === "function" ? val : String(val);
    }
    exports2.E = E;
    exports2.Error = makeNodeError(g.Error);
    exports2.TypeError = makeNodeError(g.TypeError);
    exports2.RangeError = makeNodeError(g.RangeError);
    E("ERR_ARG_NOT_ITERABLE", "%s must be iterable");
    E("ERR_ASSERTION", "%s");
    E("ERR_BUFFER_OUT_OF_BOUNDS", bufferOutOfBounds);
    E("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
    E("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s");
    E("ERR_CPU_USAGE", "Unable to obtain cpu usage %s");
    E("ERR_DNS_SET_SERVERS_FAILED", function(err, servers) {
      return 'c-ares failed to set servers: "'.concat(err, '" [').concat(servers, "]");
    });
    E("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
    E("ERR_ENCODING_NOT_SUPPORTED", function(enc) {
      return 'The "'.concat(enc, '" encoding is not supported');
    });
    E("ERR_ENCODING_INVALID_ENCODED_DATA", function(enc) {
      return "The encoded data was not valid for encoding ".concat(enc);
    });
    E("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client");
    E("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s");
    E("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding");
    E("ERR_INDEX_OUT_OF_RANGE", "Index out of range");
    E("ERR_INVALID_ARG_TYPE", invalidArgType);
    E("ERR_INVALID_ARRAY_LENGTH", function(name, len, actual) {
      assert.strictEqual(typeof actual, "number");
      return 'The array "'.concat(name, '" (length ').concat(actual, ") must be of length ").concat(len, ".");
    });
    E("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s");
    E("ERR_INVALID_CALLBACK", "Callback must be a function");
    E("ERR_INVALID_CHAR", "Invalid character in %s");
    E("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column");
    E("ERR_INVALID_FD", '"fd" must be a positive integer: %s');
    E("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
    E("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
    E("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent");
    E("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s");
    E("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "'.concat(String(value), '" is invalid for option "').concat(name, '"');
    });
    E("ERR_INVALID_OPT_VALUE_ENCODING", function(value) {
      return 'The value "'.concat(String(value), '" is invalid for option "encoding"');
    });
    E("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
    E("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s");
    E("ERR_INVALID_THIS", 'Value of "this" must be of type %s');
    E("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple");
    E("ERR_INVALID_URL", "Invalid URL: %s");
    E("ERR_INVALID_URL_SCHEME", function(expected) {
      return "The URL must be ".concat(oneOf(expected, "scheme"));
    });
    E("ERR_IPC_CHANNEL_CLOSED", "Channel closed");
    E("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected");
    E("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe");
    E("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks");
    E("ERR_MISSING_ARGS", missingArgs);
    E("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    E("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function");
    E("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object");
    E("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support");
    E("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported");
    E("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s");
    E("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound");
    E("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536");
    E("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6");
    E("ERR_SOCKET_CANNOT_SEND", "Unable to send data");
    E("ERR_SOCKET_CLOSED", "Socket is closed");
    E("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running");
    E("ERR_STDERR_CLOSE", "process.stderr cannot be closed");
    E("ERR_STDOUT_CLOSE", "process.stdout cannot be closed");
    E("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode");
    E("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s");
    E("ERR_TLS_DH_PARAM_SIZE", function(size) {
      return "DH parameter size ".concat(size, " is less than 2048");
    });
    E("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout");
    E("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate");
    E("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext');
    E("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected");
    E("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming");
    E("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0");
    E("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s");
    E("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s");
    E("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type");
    E("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type");
    E("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
    function invalidArgType(name, expected, actual) {
      assert(name, "name is required");
      var determiner;
      if (expected.includes("not ")) {
        determiner = "must not be";
        expected = expected.split("not ")[1];
      } else {
        determiner = "must be";
      }
      var msg;
      if (Array.isArray(name)) {
        var names = name.map(function(val) {
          return '"'.concat(val, '"');
        }).join(", ");
        msg = "The ".concat(names, " arguments ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else if (name.includes(" argument")) {
        msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = name.includes(".") ? "property" : "argument";
        msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      if (arguments.length >= 3) {
        msg += ". Received type ".concat(actual !== null ? typeof actual : "null");
      }
      return msg;
    }
    function missingArgs() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      assert(args.length > 0, "At least one arg needs to be specified");
      var msg = "The ";
      var len = args.length;
      args = args.map(function(a) {
        return '"'.concat(a, '"');
      });
      switch (len) {
        case 1:
          msg += "".concat(args[0], " argument");
          break;
        case 2:
          msg += "".concat(args[0], " and ").concat(args[1], " arguments");
          break;
        default:
          msg += args.slice(0, len - 1).join(", ");
          msg += ", and ".concat(args[len - 1], " arguments");
          break;
      }
      return "".concat(msg, " must be specified");
    }
    function oneOf(expected, thing) {
      assert(expected, "expected is required");
      assert(typeof thing === "string", "thing is required");
      if (Array.isArray(expected)) {
        var len = expected.length;
        assert(len > 0, "At least one expected value needs to be specified");
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function bufferOutOfBounds(name, isWriting) {
      if (isWriting) {
        return "Attempt to write outside buffer bounds";
      } else {
        return '"'.concat(name, '" is outside of buffer bounds');
      }
    }
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/encoding.js
var require_encoding = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/encoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.strToEncoding = exports2.assertEncoding = exports2.ENCODING_UTF8 = void 0;
    var buffer_1 = require_buffer();
    var errors = require_errors();
    exports2.ENCODING_UTF8 = "utf8";
    function assertEncoding(encoding) {
      if (encoding && !buffer_1.Buffer.isEncoding(encoding))
        throw new errors.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", encoding);
    }
    exports2.assertEncoding = assertEncoding;
    function strToEncoding(str, encoding) {
      if (!encoding || encoding === exports2.ENCODING_UTF8)
        return str;
      if (encoding === "buffer")
        return new buffer_1.Buffer(str);
      return new buffer_1.Buffer(str).toString(encoding);
    }
    exports2.strToEncoding = strToEncoding;
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/Dirent.js
var require_Dirent = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/Dirent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Dirent = void 0;
    var constants_1 = require_constants();
    var encoding_1 = require_encoding();
    var S_IFMT = constants_1.constants.S_IFMT;
    var S_IFDIR = constants_1.constants.S_IFDIR;
    var S_IFREG = constants_1.constants.S_IFREG;
    var S_IFBLK = constants_1.constants.S_IFBLK;
    var S_IFCHR = constants_1.constants.S_IFCHR;
    var S_IFLNK = constants_1.constants.S_IFLNK;
    var S_IFIFO = constants_1.constants.S_IFIFO;
    var S_IFSOCK = constants_1.constants.S_IFSOCK;
    var Dirent = (
      /** @class */
      function() {
        function Dirent2() {
          this.name = "";
          this.mode = 0;
        }
        Dirent2.build = function(link, encoding) {
          var dirent = new Dirent2();
          var mode = link.getNode().mode;
          dirent.name = (0, encoding_1.strToEncoding)(link.getName(), encoding);
          dirent.mode = mode;
          return dirent;
        };
        Dirent2.prototype._checkModeProperty = function(property) {
          return (this.mode & S_IFMT) === property;
        };
        Dirent2.prototype.isDirectory = function() {
          return this._checkModeProperty(S_IFDIR);
        };
        Dirent2.prototype.isFile = function() {
          return this._checkModeProperty(S_IFREG);
        };
        Dirent2.prototype.isBlockDevice = function() {
          return this._checkModeProperty(S_IFBLK);
        };
        Dirent2.prototype.isCharacterDevice = function() {
          return this._checkModeProperty(S_IFCHR);
        };
        Dirent2.prototype.isSymbolicLink = function() {
          return this._checkModeProperty(S_IFLNK);
        };
        Dirent2.prototype.isFIFO = function() {
          return this._checkModeProperty(S_IFIFO);
        };
        Dirent2.prototype.isSocket = function() {
          return this._checkModeProperty(S_IFSOCK);
        };
        return Dirent2;
      }()
    );
    exports2.Dirent = Dirent;
    exports2.default = Dirent;
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/setImmediate.js
var require_setImmediate = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/setImmediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _setImmediate;
    if (typeof setImmediate === "function")
      _setImmediate = setImmediate.bind(typeof globalThis !== "undefined" ? globalThis : global);
    else
      _setImmediate = setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : global);
    exports2.default = _setImmediate;
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/process.js
var require_process = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/process.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProcess = void 0;
    var maybeReturnProcess = function() {
      if (typeof process !== "undefined") {
        return process;
      }
      try {
        return require("process");
      } catch (_a) {
        return void 0;
      }
    };
    function createProcess() {
      var p = maybeReturnProcess() || {};
      if (!p.cwd)
        p.cwd = function() {
          return "/";
        };
      if (!p.nextTick)
        p.nextTick = require_setImmediate().default;
      if (!p.emitWarning)
        p.emitWarning = function(message, type) {
          console.warn("".concat(type).concat(type ? ": " : "").concat(message));
        };
      if (!p.env)
        p.env = {};
      return p;
    }
    exports2.createProcess = createProcess;
    exports2.default = createProcess();
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/node.js
var require_node = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/node.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.File = exports2.Link = exports2.Node = exports2.SEP = void 0;
    var process_1 = require_process();
    var buffer_1 = require_buffer();
    var constants_1 = require_constants();
    var events_1 = require("events");
    var Stats_1 = require_Stats();
    var S_IFMT = constants_1.constants.S_IFMT;
    var S_IFDIR = constants_1.constants.S_IFDIR;
    var S_IFREG = constants_1.constants.S_IFREG;
    var S_IFLNK = constants_1.constants.S_IFLNK;
    var O_APPEND = constants_1.constants.O_APPEND;
    var getuid = function() {
      var _a, _b;
      return (_b = (_a = process_1.default.getuid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0;
    };
    var getgid = function() {
      var _a, _b;
      return (_b = (_a = process_1.default.getgid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0;
    };
    exports2.SEP = "/";
    var Node = (
      /** @class */
      function(_super) {
        __extends(Node2, _super);
        function Node2(ino, perm) {
          if (perm === void 0) {
            perm = 438;
          }
          var _this = _super.call(this) || this;
          _this._uid = getuid();
          _this._gid = getgid();
          _this._atime = /* @__PURE__ */ new Date();
          _this._mtime = /* @__PURE__ */ new Date();
          _this._ctime = /* @__PURE__ */ new Date();
          _this._perm = 438;
          _this.mode = S_IFREG;
          _this._nlink = 1;
          _this._perm = perm;
          _this.mode |= perm;
          _this.ino = ino;
          return _this;
        }
        Object.defineProperty(Node2.prototype, "ctime", {
          get: function() {
            return this._ctime;
          },
          set: function(ctime) {
            this._ctime = ctime;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "uid", {
          get: function() {
            return this._uid;
          },
          set: function(uid) {
            this._uid = uid;
            this.ctime = /* @__PURE__ */ new Date();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "gid", {
          get: function() {
            return this._gid;
          },
          set: function(gid) {
            this._gid = gid;
            this.ctime = /* @__PURE__ */ new Date();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "atime", {
          get: function() {
            return this._atime;
          },
          set: function(atime) {
            this._atime = atime;
            this.ctime = /* @__PURE__ */ new Date();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "mtime", {
          get: function() {
            return this._mtime;
          },
          set: function(mtime) {
            this._mtime = mtime;
            this.ctime = /* @__PURE__ */ new Date();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "perm", {
          get: function() {
            return this._perm;
          },
          set: function(perm) {
            this._perm = perm;
            this.ctime = /* @__PURE__ */ new Date();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "nlink", {
          get: function() {
            return this._nlink;
          },
          set: function(nlink) {
            this._nlink = nlink;
            this.ctime = /* @__PURE__ */ new Date();
          },
          enumerable: false,
          configurable: true
        });
        Node2.prototype.getString = function(encoding) {
          if (encoding === void 0) {
            encoding = "utf8";
          }
          this.atime = /* @__PURE__ */ new Date();
          return this.getBuffer().toString(encoding);
        };
        Node2.prototype.setString = function(str) {
          this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
          this.touch();
        };
        Node2.prototype.getBuffer = function() {
          this.atime = /* @__PURE__ */ new Date();
          if (!this.buf)
            this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
          return (0, buffer_1.bufferFrom)(this.buf);
        };
        Node2.prototype.setBuffer = function(buf) {
          this.buf = (0, buffer_1.bufferFrom)(buf);
          this.touch();
        };
        Node2.prototype.getSize = function() {
          return this.buf ? this.buf.length : 0;
        };
        Node2.prototype.setModeProperty = function(property) {
          this.mode = this.mode & ~S_IFMT | property;
        };
        Node2.prototype.setIsFile = function() {
          this.setModeProperty(S_IFREG);
        };
        Node2.prototype.setIsDirectory = function() {
          this.setModeProperty(S_IFDIR);
        };
        Node2.prototype.setIsSymlink = function() {
          this.setModeProperty(S_IFLNK);
        };
        Node2.prototype.isFile = function() {
          return (this.mode & S_IFMT) === S_IFREG;
        };
        Node2.prototype.isDirectory = function() {
          return (this.mode & S_IFMT) === S_IFDIR;
        };
        Node2.prototype.isSymlink = function() {
          return (this.mode & S_IFMT) === S_IFLNK;
        };
        Node2.prototype.makeSymlink = function(steps) {
          this.symlink = steps;
          this.setIsSymlink();
        };
        Node2.prototype.write = function(buf, off, len, pos) {
          if (off === void 0) {
            off = 0;
          }
          if (len === void 0) {
            len = buf.length;
          }
          if (pos === void 0) {
            pos = 0;
          }
          if (!this.buf)
            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          if (pos + len > this.buf.length) {
            var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
            this.buf.copy(newBuf, 0, 0, this.buf.length);
            this.buf = newBuf;
          }
          buf.copy(this.buf, pos, off, off + len);
          this.touch();
          return len;
        };
        Node2.prototype.read = function(buf, off, len, pos) {
          if (off === void 0) {
            off = 0;
          }
          if (len === void 0) {
            len = buf.byteLength;
          }
          if (pos === void 0) {
            pos = 0;
          }
          this.atime = /* @__PURE__ */ new Date();
          if (!this.buf)
            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          var actualLen = len;
          if (actualLen > buf.byteLength) {
            actualLen = buf.byteLength;
          }
          if (actualLen + pos > this.buf.length) {
            actualLen = this.buf.length - pos;
          }
          this.buf.copy(buf, off, pos, pos + actualLen);
          return actualLen;
        };
        Node2.prototype.truncate = function(len) {
          if (len === void 0) {
            len = 0;
          }
          if (!len)
            this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          else {
            if (!this.buf)
              this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
            if (len <= this.buf.length) {
              this.buf = this.buf.slice(0, len);
            } else {
              var buf = (0, buffer_1.bufferAllocUnsafe)(len);
              this.buf.copy(buf);
              buf.fill(0, this.buf.length);
              this.buf = buf;
            }
          }
          this.touch();
        };
        Node2.prototype.chmod = function(perm) {
          this.perm = perm;
          this.mode = this.mode & ~511 | perm;
          this.touch();
        };
        Node2.prototype.chown = function(uid, gid) {
          this.uid = uid;
          this.gid = gid;
          this.touch();
        };
        Node2.prototype.touch = function() {
          this.mtime = /* @__PURE__ */ new Date();
          this.emit("change", this);
        };
        Node2.prototype.canRead = function(uid, gid) {
          if (uid === void 0) {
            uid = getuid();
          }
          if (gid === void 0) {
            gid = getgid();
          }
          if (this.perm & 4) {
            return true;
          }
          if (gid === this.gid) {
            if (this.perm & 32) {
              return true;
            }
          }
          if (uid === this.uid) {
            if (this.perm & 256) {
              return true;
            }
          }
          return false;
        };
        Node2.prototype.canWrite = function(uid, gid) {
          if (uid === void 0) {
            uid = getuid();
          }
          if (gid === void 0) {
            gid = getgid();
          }
          if (this.perm & 2) {
            return true;
          }
          if (gid === this.gid) {
            if (this.perm & 16) {
              return true;
            }
          }
          if (uid === this.uid) {
            if (this.perm & 128) {
              return true;
            }
          }
          return false;
        };
        Node2.prototype.del = function() {
          this.emit("delete", this);
        };
        Node2.prototype.toJSON = function() {
          return {
            ino: this.ino,
            uid: this.uid,
            gid: this.gid,
            atime: this.atime.getTime(),
            mtime: this.mtime.getTime(),
            ctime: this.ctime.getTime(),
            perm: this.perm,
            mode: this.mode,
            nlink: this.nlink,
            symlink: this.symlink,
            data: this.getString()
          };
        };
        return Node2;
      }(events_1.EventEmitter)
    );
    exports2.Node = Node;
    var Link = (
      /** @class */
      function(_super) {
        __extends(Link2, _super);
        function Link2(vol, parent, name) {
          var _this = _super.call(this) || this;
          _this.children = {};
          _this._steps = [];
          _this.ino = 0;
          _this.length = 0;
          _this.vol = vol;
          _this.parent = parent;
          _this.name = name;
          _this.syncSteps();
          return _this;
        }
        Object.defineProperty(Link2.prototype, "steps", {
          get: function() {
            return this._steps;
          },
          // Recursively sync children steps, e.g. in case of dir rename
          set: function(val) {
            this._steps = val;
            for (var _i = 0, _a = Object.entries(this.children); _i < _a.length; _i++) {
              var _b = _a[_i], child = _b[0], link = _b[1];
              if (child === "." || child === "..") {
                continue;
              }
              link === null || link === void 0 ? void 0 : link.syncSteps();
            }
          },
          enumerable: false,
          configurable: true
        });
        Link2.prototype.setNode = function(node) {
          this.node = node;
          this.ino = node.ino;
        };
        Link2.prototype.getNode = function() {
          return this.node;
        };
        Link2.prototype.createChild = function(name, node) {
          if (node === void 0) {
            node = this.vol.createNode();
          }
          var link = new Link2(this.vol, this, name);
          link.setNode(node);
          if (node.isDirectory()) {
            link.children["."] = link;
            link.getNode().nlink++;
          }
          this.setChild(name, link);
          return link;
        };
        Link2.prototype.setChild = function(name, link) {
          if (link === void 0) {
            link = new Link2(this.vol, this, name);
          }
          this.children[name] = link;
          link.parent = this;
          this.length++;
          var node = link.getNode();
          if (node.isDirectory()) {
            link.children[".."] = this;
            this.getNode().nlink++;
          }
          this.getNode().mtime = /* @__PURE__ */ new Date();
          this.emit("child:add", link, this);
          return link;
        };
        Link2.prototype.deleteChild = function(link) {
          var node = link.getNode();
          if (node.isDirectory()) {
            delete link.children[".."];
            this.getNode().nlink--;
          }
          delete this.children[link.getName()];
          this.length--;
          this.getNode().mtime = /* @__PURE__ */ new Date();
          this.emit("child:delete", link, this);
        };
        Link2.prototype.getChild = function(name) {
          this.getNode().mtime = /* @__PURE__ */ new Date();
          if (Object.hasOwnProperty.call(this.children, name)) {
            return this.children[name];
          }
        };
        Link2.prototype.getPath = function() {
          return this.steps.join(exports2.SEP);
        };
        Link2.prototype.getName = function() {
          return this.steps[this.steps.length - 1];
        };
        Link2.prototype.walk = function(steps, stop, i) {
          if (stop === void 0) {
            stop = steps.length;
          }
          if (i === void 0) {
            i = 0;
          }
          if (i >= steps.length)
            return this;
          if (i >= stop)
            return this;
          var step = steps[i];
          var link = this.getChild(step);
          if (!link)
            return null;
          return link.walk(steps, stop, i + 1);
        };
        Link2.prototype.toJSON = function() {
          return {
            steps: this.steps,
            ino: this.ino,
            children: Object.keys(this.children)
          };
        };
        Link2.prototype.syncSteps = function() {
          this.steps = this.parent ? this.parent.steps.concat([this.name]) : [this.name];
        };
        return Link2;
      }(events_1.EventEmitter)
    );
    exports2.Link = Link;
    var File = (
      /** @class */
      function() {
        function File2(link, node, flags, fd) {
          this.position = 0;
          this.link = link;
          this.node = node;
          this.flags = flags;
          this.fd = fd;
        }
        File2.prototype.getString = function(encoding) {
          if (encoding === void 0) {
            encoding = "utf8";
          }
          return this.node.getString();
        };
        File2.prototype.setString = function(str) {
          this.node.setString(str);
        };
        File2.prototype.getBuffer = function() {
          return this.node.getBuffer();
        };
        File2.prototype.setBuffer = function(buf) {
          this.node.setBuffer(buf);
        };
        File2.prototype.getSize = function() {
          return this.node.getSize();
        };
        File2.prototype.truncate = function(len) {
          this.node.truncate(len);
        };
        File2.prototype.seekTo = function(position) {
          this.position = position;
        };
        File2.prototype.stats = function() {
          return Stats_1.default.build(this.node);
        };
        File2.prototype.write = function(buf, offset, length, position) {
          if (offset === void 0) {
            offset = 0;
          }
          if (length === void 0) {
            length = buf.length;
          }
          if (typeof position !== "number")
            position = this.position;
          if (this.flags & O_APPEND)
            position = this.getSize();
          var bytes = this.node.write(buf, offset, length, position);
          this.position = position + bytes;
          return bytes;
        };
        File2.prototype.read = function(buf, offset, length, position) {
          if (offset === void 0) {
            offset = 0;
          }
          if (length === void 0) {
            length = buf.byteLength;
          }
          if (typeof position !== "number")
            position = this.position;
          var bytes = this.node.read(buf, offset, length, position);
          this.position = position + bytes;
          return bytes;
        };
        File2.prototype.chmod = function(perm) {
          this.node.chmod(perm);
        };
        File2.prototype.chown = function(uid, gid) {
          this.node.chown(uid, gid);
        };
        return File2;
      }()
    );
    exports2.File = File;
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/setTimeoutUnref.js
var require_setTimeoutUnref = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/setTimeoutUnref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function setTimeoutUnref(callback, time, args) {
      var ref = setTimeout.apply(typeof globalThis !== "undefined" ? globalThis : global, arguments);
      if (ref && typeof ref === "object" && typeof ref.unref === "function")
        ref.unref();
      return ref;
    }
    exports2.default = setTimeoutUnref;
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/promises.js
var require_promises = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/promises.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileHandle = void 0;
    function promisify(vol, fn, getResult) {
      if (getResult === void 0) {
        getResult = function(input) {
          return input;
        };
      }
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return new Promise(function(resolve, reject) {
          vol[fn].bind(vol).apply(void 0, __spreadArray(__spreadArray([], args, false), [function(error, result) {
            if (error)
              return reject(error);
            return resolve(getResult(result));
          }], false));
        });
      };
    }
    var FileHandle = (
      /** @class */
      function() {
        function FileHandle2(vol, fd) {
          this.vol = vol;
          this.fd = fd;
        }
        FileHandle2.prototype.appendFile = function(data, options) {
          return promisify(this.vol, "appendFile")(this.fd, data, options);
        };
        FileHandle2.prototype.chmod = function(mode) {
          return promisify(this.vol, "fchmod")(this.fd, mode);
        };
        FileHandle2.prototype.chown = function(uid, gid) {
          return promisify(this.vol, "fchown")(this.fd, uid, gid);
        };
        FileHandle2.prototype.close = function() {
          return promisify(this.vol, "close")(this.fd);
        };
        FileHandle2.prototype.datasync = function() {
          return promisify(this.vol, "fdatasync")(this.fd);
        };
        FileHandle2.prototype.read = function(buffer, offset, length, position) {
          return promisify(this.vol, "read", function(bytesRead) {
            return { bytesRead, buffer };
          })(this.fd, buffer, offset, length, position);
        };
        FileHandle2.prototype.readFile = function(options) {
          return promisify(this.vol, "readFile")(this.fd, options);
        };
        FileHandle2.prototype.stat = function(options) {
          return promisify(this.vol, "fstat")(this.fd, options);
        };
        FileHandle2.prototype.sync = function() {
          return promisify(this.vol, "fsync")(this.fd);
        };
        FileHandle2.prototype.truncate = function(len) {
          return promisify(this.vol, "ftruncate")(this.fd, len);
        };
        FileHandle2.prototype.utimes = function(atime, mtime) {
          return promisify(this.vol, "futimes")(this.fd, atime, mtime);
        };
        FileHandle2.prototype.write = function(buffer, offset, length, position) {
          return promisify(this.vol, "write", function(bytesWritten) {
            return { bytesWritten, buffer };
          })(this.fd, buffer, offset, length, position);
        };
        FileHandle2.prototype.writeFile = function(data, options) {
          return promisify(this.vol, "writeFile")(this.fd, data, options);
        };
        return FileHandle2;
      }()
    );
    exports2.FileHandle = FileHandle;
    function createPromisesApi(vol) {
      if (typeof Promise === "undefined")
        return null;
      return {
        FileHandle,
        access: function(path3, mode) {
          return promisify(vol, "access")(path3, mode);
        },
        appendFile: function(path3, data, options) {
          return promisify(vol, "appendFile")(path3 instanceof FileHandle ? path3.fd : path3, data, options);
        },
        chmod: function(path3, mode) {
          return promisify(vol, "chmod")(path3, mode);
        },
        chown: function(path3, uid, gid) {
          return promisify(vol, "chown")(path3, uid, gid);
        },
        copyFile: function(src, dest, flags) {
          return promisify(vol, "copyFile")(src, dest, flags);
        },
        lchmod: function(path3, mode) {
          return promisify(vol, "lchmod")(path3, mode);
        },
        lchown: function(path3, uid, gid) {
          return promisify(vol, "lchown")(path3, uid, gid);
        },
        link: function(existingPath, newPath) {
          return promisify(vol, "link")(existingPath, newPath);
        },
        lstat: function(path3, options) {
          return promisify(vol, "lstat")(path3, options);
        },
        mkdir: function(path3, options) {
          return promisify(vol, "mkdir")(path3, options);
        },
        mkdtemp: function(prefix, options) {
          return promisify(vol, "mkdtemp")(prefix, options);
        },
        open: function(path3, flags, mode) {
          return promisify(vol, "open", function(fd) {
            return new FileHandle(vol, fd);
          })(path3, flags, mode);
        },
        readdir: function(path3, options) {
          return promisify(vol, "readdir")(path3, options);
        },
        readFile: function(id, options) {
          return promisify(vol, "readFile")(id instanceof FileHandle ? id.fd : id, options);
        },
        readlink: function(path3, options) {
          return promisify(vol, "readlink")(path3, options);
        },
        realpath: function(path3, options) {
          return promisify(vol, "realpath")(path3, options);
        },
        rename: function(oldPath, newPath) {
          return promisify(vol, "rename")(oldPath, newPath);
        },
        rmdir: function(path3) {
          return promisify(vol, "rmdir")(path3);
        },
        rm: function(path3, options) {
          return promisify(vol, "rm")(path3, options);
        },
        stat: function(path3, options) {
          return promisify(vol, "stat")(path3, options);
        },
        symlink: function(target, path3, type) {
          return promisify(vol, "symlink")(target, path3, type);
        },
        truncate: function(path3, len) {
          return promisify(vol, "truncate")(path3, len);
        },
        unlink: function(path3) {
          return promisify(vol, "unlink")(path3);
        },
        utimes: function(path3, atime, mtime) {
          return promisify(vol, "utimes")(path3, atime, mtime);
        },
        writeFile: function(id, data, options) {
          return promisify(vol, "writeFile")(id instanceof FileHandle ? id.fd : id, data, options);
        }
      };
    }
    exports2.default = createPromisesApi;
  }
});

// ../../node_modules/.pnpm/fs-monkey@1.0.6/node_modules/fs-monkey/lib/correctPath.js
var require_correctPath = __commonJS({
  "../../node_modules/.pnpm/fs-monkey@1.0.6/node_modules/fs-monkey/lib/correctPath.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.correctPath = correctPath;
    exports2.unixify = unixify;
    var isWin = process.platform === "win32";
    function removeTrailingSeparator(str) {
      var i = str.length - 1;
      if (i < 2) {
        return str;
      }
      while (isSeparator(str, i)) {
        i--;
      }
      return str.substr(0, i + 1);
    }
    function isSeparator(str, i) {
      var _char = str[i];
      return i > 0 && (_char === "/" || isWin && _char === "\\");
    }
    function normalizePath(str, stripTrailing) {
      if (typeof str !== "string") {
        throw new TypeError("expected a string");
      }
      str = str.replace(/[\\\/]+/g, "/");
      if (stripTrailing !== false) {
        str = removeTrailingSeparator(str);
      }
      return str;
    }
    function unixify(filepath) {
      var stripTrailing = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      if (isWin) {
        filepath = normalizePath(filepath, stripTrailing);
        return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
      }
      return filepath;
    }
    function correctPath(filepath) {
      return unixify(filepath.replace(/^\\\\\?\\.:\\/, "\\"));
    }
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/volume.js
var require_volume = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/volume.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FSWatcher = exports2.StatWatcher = exports2.Volume = exports2.toUnixTimestamp = exports2.bufferToEncoding = exports2.dataToBuffer = exports2.dataToStr = exports2.pathToSteps = exports2.filenameToSteps = exports2.pathToFilename = exports2.flagsToNumber = exports2.FLAGS = void 0;
    var pathModule = require("path");
    var node_1 = require_node();
    var Stats_1 = require_Stats();
    var Dirent_1 = require_Dirent();
    var buffer_1 = require_buffer();
    var setImmediate_1 = require_setImmediate();
    var process_1 = require_process();
    var setTimeoutUnref_1 = require_setTimeoutUnref();
    var stream_1 = require("stream");
    var constants_1 = require_constants();
    var events_1 = require("events");
    var encoding_1 = require_encoding();
    var errors = require_errors();
    var util = require("util");
    var promises_1 = require_promises();
    var resolveCrossPlatform = pathModule.resolve;
    var O_RDONLY = constants_1.constants.O_RDONLY;
    var O_WRONLY = constants_1.constants.O_WRONLY;
    var O_RDWR = constants_1.constants.O_RDWR;
    var O_CREAT = constants_1.constants.O_CREAT;
    var O_EXCL = constants_1.constants.O_EXCL;
    var O_TRUNC = constants_1.constants.O_TRUNC;
    var O_APPEND = constants_1.constants.O_APPEND;
    var O_SYNC = constants_1.constants.O_SYNC;
    var O_DIRECTORY = constants_1.constants.O_DIRECTORY;
    var F_OK = constants_1.constants.F_OK;
    var COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL;
    var COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
    var _a = pathModule.posix ? pathModule.posix : pathModule;
    var sep = _a.sep;
    var relative = _a.relative;
    var join = _a.join;
    var dirname2 = _a.dirname;
    var isWin = process_1.default.platform === "win32";
    var kMinPoolSpace = 128;
    var ERRSTR = {
      PATH_STR: "path must be a string or Buffer",
      // FD:             'file descriptor must be a unsigned 32-bit integer',
      FD: "fd must be a file descriptor",
      MODE_INT: "mode must be an int",
      CB: "callback must be a function",
      UID: "uid must be an unsigned int",
      GID: "gid must be an unsigned int",
      LEN: "len must be an integer",
      ATIME: "atime must be an integer",
      MTIME: "mtime must be an integer",
      PREFIX: "filename prefix is required",
      BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
      OFFSET: "offset must be an integer",
      LENGTH: "length must be an integer",
      POSITION: "position must be an integer"
    };
    var ERRSTR_OPTS = function(tipeof) {
      return "Expected options to be either an object or a string, but got ".concat(tipeof, " instead");
    };
    var ENOENT = "ENOENT";
    var EBADF = "EBADF";
    var EINVAL = "EINVAL";
    var EPERM = "EPERM";
    var EPROTO = "EPROTO";
    var EEXIST = "EEXIST";
    var ENOTDIR = "ENOTDIR";
    var EMFILE = "EMFILE";
    var EACCES = "EACCES";
    var EISDIR = "EISDIR";
    var ENOTEMPTY = "ENOTEMPTY";
    var ENOSYS = "ENOSYS";
    var ERR_FS_EISDIR = "ERR_FS_EISDIR";
    function formatError(errorCode, func, path3, path22) {
      if (func === void 0) {
        func = "";
      }
      if (path3 === void 0) {
        path3 = "";
      }
      if (path22 === void 0) {
        path22 = "";
      }
      var pathFormatted = "";
      if (path3)
        pathFormatted = " '".concat(path3, "'");
      if (path22)
        pathFormatted += " -> '".concat(path22, "'");
      switch (errorCode) {
        case ENOENT:
          return "ENOENT: no such file or directory, ".concat(func).concat(pathFormatted);
        case EBADF:
          return "EBADF: bad file descriptor, ".concat(func).concat(pathFormatted);
        case EINVAL:
          return "EINVAL: invalid argument, ".concat(func).concat(pathFormatted);
        case EPERM:
          return "EPERM: operation not permitted, ".concat(func).concat(pathFormatted);
        case EPROTO:
          return "EPROTO: protocol error, ".concat(func).concat(pathFormatted);
        case EEXIST:
          return "EEXIST: file already exists, ".concat(func).concat(pathFormatted);
        case ENOTDIR:
          return "ENOTDIR: not a directory, ".concat(func).concat(pathFormatted);
        case EISDIR:
          return "EISDIR: illegal operation on a directory, ".concat(func).concat(pathFormatted);
        case EACCES:
          return "EACCES: permission denied, ".concat(func).concat(pathFormatted);
        case ENOTEMPTY:
          return "ENOTEMPTY: directory not empty, ".concat(func).concat(pathFormatted);
        case EMFILE:
          return "EMFILE: too many open files, ".concat(func).concat(pathFormatted);
        case ENOSYS:
          return "ENOSYS: function not implemented, ".concat(func).concat(pathFormatted);
        case ERR_FS_EISDIR:
          return "[ERR_FS_EISDIR]: Path is a directory: ".concat(func, " returned EISDIR (is a directory) ").concat(path3);
        default:
          return "".concat(errorCode, ": error occurred, ").concat(func).concat(pathFormatted);
      }
    }
    function createError(errorCode, func, path3, path22, Constructor) {
      if (func === void 0) {
        func = "";
      }
      if (path3 === void 0) {
        path3 = "";
      }
      if (path22 === void 0) {
        path22 = "";
      }
      if (Constructor === void 0) {
        Constructor = Error;
      }
      var error = new Constructor(formatError(errorCode, func, path3, path22));
      error.code = errorCode;
      if (path3) {
        error.path = path3;
      }
      return error;
    }
    var FLAGS;
    (function(FLAGS2) {
      FLAGS2[FLAGS2["r"] = O_RDONLY] = "r";
      FLAGS2[FLAGS2["r+"] = O_RDWR] = "r+";
      FLAGS2[FLAGS2["rs"] = O_RDONLY | O_SYNC] = "rs";
      FLAGS2[FLAGS2["sr"] = FLAGS2.rs] = "sr";
      FLAGS2[FLAGS2["rs+"] = O_RDWR | O_SYNC] = "rs+";
      FLAGS2[FLAGS2["sr+"] = FLAGS2["rs+"]] = "sr+";
      FLAGS2[FLAGS2["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
      FLAGS2[FLAGS2["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
      FLAGS2[FLAGS2["xw"] = FLAGS2.wx] = "xw";
      FLAGS2[FLAGS2["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
      FLAGS2[FLAGS2["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
      FLAGS2[FLAGS2["xw+"] = FLAGS2["wx+"]] = "xw+";
      FLAGS2[FLAGS2["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
      FLAGS2[FLAGS2["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
      FLAGS2[FLAGS2["xa"] = FLAGS2.ax] = "xa";
      FLAGS2[FLAGS2["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
      FLAGS2[FLAGS2["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
      FLAGS2[FLAGS2["xa+"] = FLAGS2["ax+"]] = "xa+";
    })(FLAGS = exports2.FLAGS || (exports2.FLAGS = {}));
    function flagsToNumber(flags) {
      if (typeof flags === "number")
        return flags;
      if (typeof flags === "string") {
        var flagsNum = FLAGS[flags];
        if (typeof flagsNum !== "undefined")
          return flagsNum;
      }
      throw new errors.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
    }
    exports2.flagsToNumber = flagsToNumber;
    function getOptions(defaults, options) {
      var opts;
      if (!options)
        return defaults;
      else {
        var tipeof = typeof options;
        switch (tipeof) {
          case "string":
            opts = Object.assign({}, defaults, { encoding: options });
            break;
          case "object":
            opts = Object.assign({}, defaults, options);
            break;
          default:
            throw TypeError(ERRSTR_OPTS(tipeof));
        }
      }
      if (opts.encoding !== "buffer")
        (0, encoding_1.assertEncoding)(opts.encoding);
      return opts;
    }
    function optsGenerator(defaults) {
      return function(options) {
        return getOptions(defaults, options);
      };
    }
    function validateCallback(callback) {
      if (typeof callback !== "function")
        throw TypeError(ERRSTR.CB);
      return callback;
    }
    function optsAndCbGenerator(getOpts) {
      return function(options, callback) {
        return typeof options === "function" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
      };
    }
    var optsDefaults = {
      encoding: "utf8"
    };
    var getDefaultOpts = optsGenerator(optsDefaults);
    var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
    var readFileOptsDefaults = {
      flag: "r"
    };
    var getReadFileOptions = optsGenerator(readFileOptsDefaults);
    var writeFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: FLAGS[FLAGS.w]
    };
    var getWriteFileOptions = optsGenerator(writeFileDefaults);
    var appendFileDefaults = {
      encoding: "utf8",
      mode: 438,
      flag: FLAGS[FLAGS.a]
    };
    var getAppendFileOpts = optsGenerator(appendFileDefaults);
    var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
    var realpathDefaults = optsDefaults;
    var getRealpathOptions = optsGenerator(realpathDefaults);
    var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
    var mkdirDefaults = {
      mode: 511,
      recursive: false
    };
    var getMkdirOptions = function(options) {
      if (typeof options === "number")
        return Object.assign({}, mkdirDefaults, { mode: options });
      return Object.assign({}, mkdirDefaults, options);
    };
    var rmdirDefaults = {
      recursive: false
    };
    var getRmdirOptions = function(options) {
      return Object.assign({}, rmdirDefaults, options);
    };
    var getRmOpts = optsGenerator(optsDefaults);
    var getRmOptsAndCb = optsAndCbGenerator(getRmOpts);
    var readdirDefaults = {
      encoding: "utf8",
      withFileTypes: false
    };
    var getReaddirOptions = optsGenerator(readdirDefaults);
    var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
    var statDefaults = {
      bigint: false
    };
    var getStatOptions = function(options) {
      if (options === void 0) {
        options = {};
      }
      return Object.assign({}, statDefaults, options);
    };
    var getStatOptsAndCb = function(options, callback) {
      return typeof options === "function" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
    };
    function getPathFromURLPosix(url) {
      if (url.hostname !== "") {
        throw new errors.TypeError("ERR_INVALID_FILE_URL_HOST", process_1.default.platform);
      }
      var pathname = url.pathname;
      for (var n = 0; n < pathname.length; n++) {
        if (pathname[n] === "%") {
          var third = pathname.codePointAt(n + 2) | 32;
          if (pathname[n + 1] === "2" && third === 102) {
            throw new errors.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
          }
        }
      }
      return decodeURIComponent(pathname);
    }
    function pathToFilename(path3) {
      if (typeof path3 !== "string" && !buffer_1.Buffer.isBuffer(path3)) {
        try {
          if (!(path3 instanceof require("url").URL))
            throw new TypeError(ERRSTR.PATH_STR);
        } catch (err) {
          throw new TypeError(ERRSTR.PATH_STR);
        }
        path3 = getPathFromURLPosix(path3);
      }
      var pathString = String(path3);
      nullCheck(pathString);
      return pathString;
    }
    exports2.pathToFilename = pathToFilename;
    var resolve = function(filename, base) {
      if (base === void 0) {
        base = process_1.default.cwd();
      }
      return resolveCrossPlatform(base, filename);
    };
    if (isWin) {
      _resolve_1 = resolve;
      unixify_1 = require_correctPath().unixify;
      resolve = function(filename, base) {
        return unixify_1(_resolve_1(filename, base));
      };
    }
    var _resolve_1;
    var unixify_1;
    function filenameToSteps(filename, base) {
      var fullPath = resolve(filename, base);
      var fullPathSansSlash = fullPath.substring(1);
      if (!fullPathSansSlash)
        return [];
      return fullPathSansSlash.split(sep);
    }
    exports2.filenameToSteps = filenameToSteps;
    function pathToSteps(path3) {
      return filenameToSteps(pathToFilename(path3));
    }
    exports2.pathToSteps = pathToSteps;
    function dataToStr(data, encoding) {
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      if (buffer_1.Buffer.isBuffer(data))
        return data.toString(encoding);
      else if (data instanceof Uint8Array)
        return (0, buffer_1.bufferFrom)(data).toString(encoding);
      else
        return String(data);
    }
    exports2.dataToStr = dataToStr;
    function dataToBuffer(data, encoding) {
      if (encoding === void 0) {
        encoding = encoding_1.ENCODING_UTF8;
      }
      if (buffer_1.Buffer.isBuffer(data))
        return data;
      else if (data instanceof Uint8Array)
        return (0, buffer_1.bufferFrom)(data);
      else
        return (0, buffer_1.bufferFrom)(String(data), encoding);
    }
    exports2.dataToBuffer = dataToBuffer;
    function bufferToEncoding(buffer, encoding) {
      if (!encoding || encoding === "buffer")
        return buffer;
      else
        return buffer.toString(encoding);
    }
    exports2.bufferToEncoding = bufferToEncoding;
    function nullCheck(path3, callback) {
      if (("" + path3).indexOf("\0") !== -1) {
        var er = new Error("Path must be a string without null bytes");
        er.code = ENOENT;
        if (typeof callback !== "function")
          throw er;
        process_1.default.nextTick(callback, er);
        return false;
      }
      return true;
    }
    function _modeToNumber(mode, def) {
      if (typeof mode === "number")
        return mode;
      if (typeof mode === "string")
        return parseInt(mode, 8);
      if (def)
        return modeToNumber(def);
      return void 0;
    }
    function modeToNumber(mode, def) {
      var result = _modeToNumber(mode, def);
      if (typeof result !== "number" || isNaN(result))
        throw new TypeError(ERRSTR.MODE_INT);
      return result;
    }
    function isFd(path3) {
      return path3 >>> 0 === path3;
    }
    function validateFd(fd) {
      if (!isFd(fd))
        throw TypeError(ERRSTR.FD);
    }
    function toUnixTimestamp(time) {
      if (typeof time === "string" && +time == time) {
        return +time;
      }
      if (time instanceof Date) {
        return time.getTime() / 1e3;
      }
      if (isFinite(time)) {
        if (time < 0) {
          return Date.now() / 1e3;
        }
        return time;
      }
      throw new Error("Cannot parse time: " + time);
    }
    exports2.toUnixTimestamp = toUnixTimestamp;
    function validateUid(uid) {
      if (typeof uid !== "number")
        throw TypeError(ERRSTR.UID);
    }
    function validateGid(gid) {
      if (typeof gid !== "number")
        throw TypeError(ERRSTR.GID);
    }
    function flattenJSON(nestedJSON) {
      var flatJSON = {};
      function flatten(pathPrefix, node) {
        for (var path3 in node) {
          var contentOrNode = node[path3];
          var joinedPath = join(pathPrefix, path3);
          if (typeof contentOrNode === "string") {
            flatJSON[joinedPath] = contentOrNode;
          } else if (typeof contentOrNode === "object" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
            flatten(joinedPath, contentOrNode);
          } else {
            flatJSON[joinedPath] = null;
          }
        }
      }
      flatten("", nestedJSON);
      return flatJSON;
    }
    var Volume = (
      /** @class */
      function() {
        function Volume2(props) {
          if (props === void 0) {
            props = {};
          }
          this.ino = 0;
          this.inodes = {};
          this.releasedInos = [];
          this.fds = {};
          this.releasedFds = [];
          this.maxFiles = 1e4;
          this.openFiles = 0;
          this.promisesApi = (0, promises_1.default)(this);
          this.statWatchers = {};
          this.props = Object.assign({ Node: node_1.Node, Link: node_1.Link, File: node_1.File }, props);
          var root = this.createLink();
          root.setNode(this.createNode(true));
          var self = this;
          this.StatWatcher = /** @class */
          function(_super) {
            __extends(StatWatcher2, _super);
            function StatWatcher2() {
              return _super.call(this, self) || this;
            }
            return StatWatcher2;
          }(StatWatcher);
          var _ReadStream = FsReadStream;
          this.ReadStream = /** @class */
          function(_super) {
            __extends(class_1, _super);
            function class_1() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              return _super.apply(this, __spreadArray([self], args, false)) || this;
            }
            return class_1;
          }(_ReadStream);
          var _WriteStream = FsWriteStream;
          this.WriteStream = /** @class */
          function(_super) {
            __extends(class_2, _super);
            function class_2() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              return _super.apply(this, __spreadArray([self], args, false)) || this;
            }
            return class_2;
          }(_WriteStream);
          this.FSWatcher = /** @class */
          function(_super) {
            __extends(FSWatcher2, _super);
            function FSWatcher2() {
              return _super.call(this, self) || this;
            }
            return FSWatcher2;
          }(FSWatcher);
          root.setChild(".", root);
          root.getNode().nlink++;
          root.setChild("..", root);
          root.getNode().nlink++;
          this.root = root;
        }
        Volume2.fromJSON = function(json, cwd) {
          var vol = new Volume2();
          vol.fromJSON(json, cwd);
          return vol;
        };
        Volume2.fromNestedJSON = function(json, cwd) {
          var vol = new Volume2();
          vol.fromNestedJSON(json, cwd);
          return vol;
        };
        Object.defineProperty(Volume2.prototype, "promises", {
          get: function() {
            if (this.promisesApi === null)
              throw new Error("Promise is not supported in this environment.");
            return this.promisesApi;
          },
          enumerable: false,
          configurable: true
        });
        Volume2.prototype.createLink = function(parent, name, isDirectory, perm) {
          if (isDirectory === void 0) {
            isDirectory = false;
          }
          if (!parent) {
            return new this.props.Link(this, null, "");
          }
          if (!name) {
            throw new Error("createLink: name cannot be empty");
          }
          return parent.createChild(name, this.createNode(isDirectory, perm));
        };
        Volume2.prototype.deleteLink = function(link) {
          var parent = link.parent;
          if (parent) {
            parent.deleteChild(link);
            return true;
          }
          return false;
        };
        Volume2.prototype.newInoNumber = function() {
          var releasedFd = this.releasedInos.pop();
          if (releasedFd)
            return releasedFd;
          else {
            this.ino = (this.ino + 1) % 4294967295;
            return this.ino;
          }
        };
        Volume2.prototype.newFdNumber = function() {
          var releasedFd = this.releasedFds.pop();
          return typeof releasedFd === "number" ? releasedFd : Volume2.fd--;
        };
        Volume2.prototype.createNode = function(isDirectory, perm) {
          if (isDirectory === void 0) {
            isDirectory = false;
          }
          var node = new this.props.Node(this.newInoNumber(), perm);
          if (isDirectory)
            node.setIsDirectory();
          this.inodes[node.ino] = node;
          return node;
        };
        Volume2.prototype.getNode = function(ino) {
          return this.inodes[ino];
        };
        Volume2.prototype.deleteNode = function(node) {
          node.del();
          delete this.inodes[node.ino];
          this.releasedInos.push(node.ino);
        };
        Volume2.prototype.genRndStr = function() {
          var str = (Math.random() + 1).toString(36).substring(2, 8);
          if (str.length === 6)
            return str;
          else
            return this.genRndStr();
        };
        Volume2.prototype.getLink = function(steps) {
          return this.root.walk(steps);
        };
        Volume2.prototype.getLinkOrThrow = function(filename, funcName) {
          var steps = filenameToSteps(filename);
          var link = this.getLink(steps);
          if (!link)
            throw createError(ENOENT, funcName, filename);
          return link;
        };
        Volume2.prototype.getResolvedLink = function(filenameOrSteps) {
          var steps = typeof filenameOrSteps === "string" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
          var link = this.root;
          var i = 0;
          while (i < steps.length) {
            var step = steps[i];
            link = link.getChild(step);
            if (!link)
              return null;
            var node = link.getNode();
            if (node.isSymlink()) {
              steps = node.symlink.concat(steps.slice(i + 1));
              link = this.root;
              i = 0;
              continue;
            }
            i++;
          }
          return link;
        };
        Volume2.prototype.getResolvedLinkOrThrow = function(filename, funcName) {
          var link = this.getResolvedLink(filename);
          if (!link)
            throw createError(ENOENT, funcName, filename);
          return link;
        };
        Volume2.prototype.resolveSymlinks = function(link) {
          return this.getResolvedLink(link.steps.slice(1));
        };
        Volume2.prototype.getLinkAsDirOrThrow = function(filename, funcName) {
          var link = this.getLinkOrThrow(filename, funcName);
          if (!link.getNode().isDirectory())
            throw createError(ENOTDIR, funcName, filename);
          return link;
        };
        Volume2.prototype.getLinkParent = function(steps) {
          return this.root.walk(steps, steps.length - 1);
        };
        Volume2.prototype.getLinkParentAsDirOrThrow = function(filenameOrSteps, funcName) {
          var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
          var link = this.getLinkParent(steps);
          if (!link)
            throw createError(ENOENT, funcName, sep + steps.join(sep));
          if (!link.getNode().isDirectory())
            throw createError(ENOTDIR, funcName, sep + steps.join(sep));
          return link;
        };
        Volume2.prototype.getFileByFd = function(fd) {
          return this.fds[String(fd)];
        };
        Volume2.prototype.getFileByFdOrThrow = function(fd, funcName) {
          if (!isFd(fd))
            throw TypeError(ERRSTR.FD);
          var file = this.getFileByFd(fd);
          if (!file)
            throw createError(EBADF, funcName);
          return file;
        };
        Volume2.prototype.wrapAsync = function(method, args, callback) {
          var _this = this;
          validateCallback(callback);
          (0, setImmediate_1.default)(function() {
            var result;
            try {
              result = method.apply(_this, args);
            } catch (err) {
              callback(err);
              return;
            }
            callback(null, result);
          });
        };
        Volume2.prototype._toJSON = function(link, json, path3) {
          var _a2;
          if (link === void 0) {
            link = this.root;
          }
          if (json === void 0) {
            json = {};
          }
          var isEmpty = true;
          var children = link.children;
          if (link.getNode().isFile()) {
            children = (_a2 = {}, _a2[link.getName()] = link.parent.getChild(link.getName()), _a2);
            link = link.parent;
          }
          for (var name_1 in children) {
            if (name_1 === "." || name_1 === "..") {
              continue;
            }
            isEmpty = false;
            var child = link.getChild(name_1);
            if (!child) {
              throw new Error("_toJSON: unexpected undefined");
            }
            var node = child.getNode();
            if (node.isFile()) {
              var filename = child.getPath();
              if (path3)
                filename = relative(path3, filename);
              json[filename] = node.getString();
            } else if (node.isDirectory()) {
              this._toJSON(child, json, path3);
            }
          }
          var dirPath = link.getPath();
          if (path3)
            dirPath = relative(path3, dirPath);
          if (dirPath && isEmpty) {
            json[dirPath] = null;
          }
          return json;
        };
        Volume2.prototype.toJSON = function(paths, json, isRelative) {
          if (json === void 0) {
            json = {};
          }
          if (isRelative === void 0) {
            isRelative = false;
          }
          var links = [];
          if (paths) {
            if (!(paths instanceof Array))
              paths = [paths];
            for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
              var path3 = paths_1[_i];
              var filename = pathToFilename(path3);
              var link = this.getResolvedLink(filename);
              if (!link)
                continue;
              links.push(link);
            }
          } else {
            links.push(this.root);
          }
          if (!links.length)
            return json;
          for (var _a2 = 0, links_1 = links; _a2 < links_1.length; _a2++) {
            var link = links_1[_a2];
            this._toJSON(link, json, isRelative ? link.getPath() : "");
          }
          return json;
        };
        Volume2.prototype.fromJSON = function(json, cwd) {
          if (cwd === void 0) {
            cwd = process_1.default.cwd();
          }
          for (var filename in json) {
            var data = json[filename];
            filename = resolve(filename, cwd);
            if (typeof data === "string") {
              var dir = dirname2(filename);
              this.mkdirpBase(
                dir,
                511
                /* MODE.DIR */
              );
              this.writeFileSync(filename, data);
            } else {
              this.mkdirpBase(
                filename,
                511
                /* MODE.DIR */
              );
            }
          }
        };
        Volume2.prototype.fromNestedJSON = function(json, cwd) {
          this.fromJSON(flattenJSON(json), cwd);
        };
        Volume2.prototype.reset = function() {
          this.ino = 0;
          this.inodes = {};
          this.releasedInos = [];
          this.fds = {};
          this.releasedFds = [];
          this.openFiles = 0;
          this.root = this.createLink();
          this.root.setNode(this.createNode(true));
        };
        Volume2.prototype.mountSync = function(mountpoint, json) {
          this.fromJSON(json, mountpoint);
        };
        Volume2.prototype.openLink = function(link, flagsNum, resolveSymlinks) {
          if (resolveSymlinks === void 0) {
            resolveSymlinks = true;
          }
          if (this.openFiles >= this.maxFiles) {
            throw createError(EMFILE, "open", link.getPath());
          }
          var realLink = link;
          if (resolveSymlinks)
            realLink = this.resolveSymlinks(link);
          if (!realLink)
            throw createError(ENOENT, "open", link.getPath());
          var node = realLink.getNode();
          if (node.isDirectory()) {
            if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY)
              throw createError(EISDIR, "open", link.getPath());
          } else {
            if (flagsNum & O_DIRECTORY)
              throw createError(ENOTDIR, "open", link.getPath());
          }
          if (!(flagsNum & O_WRONLY)) {
            if (!node.canRead()) {
              throw createError(EACCES, "open", link.getPath());
            }
          }
          if (flagsNum & O_RDWR) {
          }
          var file = new this.props.File(link, node, flagsNum, this.newFdNumber());
          this.fds[file.fd] = file;
          this.openFiles++;
          if (flagsNum & O_TRUNC)
            file.truncate();
          return file;
        };
        Volume2.prototype.openFile = function(filename, flagsNum, modeNum, resolveSymlinks) {
          if (resolveSymlinks === void 0) {
            resolveSymlinks = true;
          }
          var steps = filenameToSteps(filename);
          var link = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps);
          if (link && flagsNum & O_EXCL)
            throw createError(EEXIST, "open", filename);
          if (!link && flagsNum & O_CREAT) {
            var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
            if (!dirLink)
              throw createError(ENOENT, "open", sep + steps.join(sep));
            if (flagsNum & O_CREAT && typeof modeNum === "number") {
              link = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
            }
          }
          if (link)
            return this.openLink(link, flagsNum, resolveSymlinks);
          throw createError(ENOENT, "open", filename);
        };
        Volume2.prototype.openBase = function(filename, flagsNum, modeNum, resolveSymlinks) {
          if (resolveSymlinks === void 0) {
            resolveSymlinks = true;
          }
          var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
          if (!file)
            throw createError(ENOENT, "open", filename);
          return file.fd;
        };
        Volume2.prototype.openSync = function(path3, flags, mode) {
          if (mode === void 0) {
            mode = 438;
          }
          var modeNum = modeToNumber(mode);
          var fileName = pathToFilename(path3);
          var flagsNum = flagsToNumber(flags);
          return this.openBase(fileName, flagsNum, modeNum);
        };
        Volume2.prototype.open = function(path3, flags, a, b) {
          var mode = a;
          var callback = b;
          if (typeof a === "function") {
            mode = 438;
            callback = a;
          }
          mode = mode || 438;
          var modeNum = modeToNumber(mode);
          var fileName = pathToFilename(path3);
          var flagsNum = flagsToNumber(flags);
          this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
        };
        Volume2.prototype.closeFile = function(file) {
          if (!this.fds[file.fd])
            return;
          this.openFiles--;
          delete this.fds[file.fd];
          this.releasedFds.push(file.fd);
        };
        Volume2.prototype.closeSync = function(fd) {
          validateFd(fd);
          var file = this.getFileByFdOrThrow(fd, "close");
          this.closeFile(file);
        };
        Volume2.prototype.close = function(fd, callback) {
          validateFd(fd);
          this.wrapAsync(this.closeSync, [fd], callback);
        };
        Volume2.prototype.openFileOrGetById = function(id, flagsNum, modeNum) {
          if (typeof id === "number") {
            var file = this.fds[id];
            if (!file)
              throw createError(ENOENT);
            return file;
          } else {
            return this.openFile(pathToFilename(id), flagsNum, modeNum);
          }
        };
        Volume2.prototype.readBase = function(fd, buffer, offset, length, position) {
          var file = this.getFileByFdOrThrow(fd);
          return file.read(buffer, Number(offset), Number(length), position);
        };
        Volume2.prototype.readSync = function(fd, buffer, offset, length, position) {
          validateFd(fd);
          return this.readBase(fd, buffer, offset, length, position);
        };
        Volume2.prototype.read = function(fd, buffer, offset, length, position, callback) {
          var _this = this;
          validateCallback(callback);
          if (length === 0) {
            return process_1.default.nextTick(function() {
              if (callback)
                callback(null, 0, buffer);
            });
          }
          (0, setImmediate_1.default)(function() {
            try {
              var bytes = _this.readBase(fd, buffer, offset, length, position);
              callback(null, bytes, buffer);
            } catch (err) {
              callback(err);
            }
          });
        };
        Volume2.prototype.readFileBase = function(id, flagsNum, encoding) {
          var result;
          var isUserFd = typeof id === "number";
          var userOwnsFd = isUserFd && isFd(id);
          var fd;
          if (userOwnsFd)
            fd = id;
          else {
            var filename = pathToFilename(id);
            var steps = filenameToSteps(filename);
            var link = this.getResolvedLink(steps);
            if (link) {
              var node = link.getNode();
              if (node.isDirectory())
                throw createError(EISDIR, "open", link.getPath());
            }
            fd = this.openSync(id, flagsNum);
          }
          try {
            result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
          } finally {
            if (!userOwnsFd) {
              this.closeSync(fd);
            }
          }
          return result;
        };
        Volume2.prototype.readFileSync = function(file, options) {
          var opts = getReadFileOptions(options);
          var flagsNum = flagsToNumber(opts.flag);
          return this.readFileBase(file, flagsNum, opts.encoding);
        };
        Volume2.prototype.readFile = function(id, a, b) {
          var _a2 = optsAndCbGenerator(getReadFileOptions)(a, b), opts = _a2[0], callback = _a2[1];
          var flagsNum = flagsToNumber(opts.flag);
          this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
        };
        Volume2.prototype.writeBase = function(fd, buf, offset, length, position) {
          var file = this.getFileByFdOrThrow(fd, "write");
          return file.write(buf, offset, length, position);
        };
        Volume2.prototype.writeSync = function(fd, a, b, c, d) {
          validateFd(fd);
          var encoding;
          var offset;
          var length;
          var position;
          var isBuffer = typeof a !== "string";
          if (isBuffer) {
            offset = (b || 0) | 0;
            length = c;
            position = d;
          } else {
            position = b;
            encoding = c;
          }
          var buf = dataToBuffer(a, encoding);
          if (isBuffer) {
            if (typeof length === "undefined") {
              length = buf.length;
            }
          } else {
            offset = 0;
            length = buf.length;
          }
          return this.writeBase(fd, buf, offset, length, position);
        };
        Volume2.prototype.write = function(fd, a, b, c, d, e) {
          var _this = this;
          validateFd(fd);
          var offset;
          var length;
          var position;
          var encoding;
          var callback;
          var tipa = typeof a;
          var tipb = typeof b;
          var tipc = typeof c;
          var tipd = typeof d;
          if (tipa !== "string") {
            if (tipb === "function") {
              callback = b;
            } else if (tipc === "function") {
              offset = b | 0;
              callback = c;
            } else if (tipd === "function") {
              offset = b | 0;
              length = c;
              callback = d;
            } else {
              offset = b | 0;
              length = c;
              position = d;
              callback = e;
            }
          } else {
            if (tipb === "function") {
              callback = b;
            } else if (tipc === "function") {
              position = b;
              callback = c;
            } else if (tipd === "function") {
              position = b;
              encoding = c;
              callback = d;
            }
          }
          var buf = dataToBuffer(a, encoding);
          if (tipa !== "string") {
            if (typeof length === "undefined")
              length = buf.length;
          } else {
            offset = 0;
            length = buf.length;
          }
          var cb = validateCallback(callback);
          (0, setImmediate_1.default)(function() {
            try {
              var bytes = _this.writeBase(fd, buf, offset, length, position);
              if (tipa !== "string") {
                cb(null, bytes, buf);
              } else {
                cb(null, bytes, a);
              }
            } catch (err) {
              cb(err);
            }
          });
        };
        Volume2.prototype.writeFileBase = function(id, buf, flagsNum, modeNum) {
          var isUserFd = typeof id === "number";
          var fd;
          if (isUserFd)
            fd = id;
          else {
            fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
          }
          var offset = 0;
          var length = buf.length;
          var position = flagsNum & O_APPEND ? void 0 : 0;
          try {
            while (length > 0) {
              var written = this.writeSync(fd, buf, offset, length, position);
              offset += written;
              length -= written;
              if (position !== void 0)
                position += written;
            }
          } finally {
            if (!isUserFd)
              this.closeSync(fd);
          }
        };
        Volume2.prototype.writeFileSync = function(id, data, options) {
          var opts = getWriteFileOptions(options);
          var flagsNum = flagsToNumber(opts.flag);
          var modeNum = modeToNumber(opts.mode);
          var buf = dataToBuffer(data, opts.encoding);
          this.writeFileBase(id, buf, flagsNum, modeNum);
        };
        Volume2.prototype.writeFile = function(id, data, a, b) {
          var options = a;
          var callback = b;
          if (typeof a === "function") {
            options = writeFileDefaults;
            callback = a;
          }
          var cb = validateCallback(callback);
          var opts = getWriteFileOptions(options);
          var flagsNum = flagsToNumber(opts.flag);
          var modeNum = modeToNumber(opts.mode);
          var buf = dataToBuffer(data, opts.encoding);
          this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
        };
        Volume2.prototype.linkBase = function(filename1, filename2) {
          var steps1 = filenameToSteps(filename1);
          var link1 = this.getLink(steps1);
          if (!link1)
            throw createError(ENOENT, "link", filename1, filename2);
          var steps2 = filenameToSteps(filename2);
          var dir2 = this.getLinkParent(steps2);
          if (!dir2)
            throw createError(ENOENT, "link", filename1, filename2);
          var name = steps2[steps2.length - 1];
          if (dir2.getChild(name))
            throw createError(EEXIST, "link", filename1, filename2);
          var node = link1.getNode();
          node.nlink++;
          dir2.createChild(name, node);
        };
        Volume2.prototype.copyFileBase = function(src, dest, flags) {
          var buf = this.readFileSync(src);
          if (flags & COPYFILE_EXCL) {
            if (this.existsSync(dest)) {
              throw createError(EEXIST, "copyFile", src, dest);
            }
          }
          if (flags & COPYFILE_FICLONE_FORCE) {
            throw createError(ENOSYS, "copyFile", src, dest);
          }
          this.writeFileBase(
            dest,
            buf,
            FLAGS.w,
            438
            /* MODE.DEFAULT */
          );
        };
        Volume2.prototype.copyFileSync = function(src, dest, flags) {
          var srcFilename = pathToFilename(src);
          var destFilename = pathToFilename(dest);
          return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
        };
        Volume2.prototype.copyFile = function(src, dest, a, b) {
          var srcFilename = pathToFilename(src);
          var destFilename = pathToFilename(dest);
          var flags;
          var callback;
          if (typeof a === "function") {
            flags = 0;
            callback = a;
          } else {
            flags = a;
            callback = b;
          }
          validateCallback(callback);
          this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
        };
        Volume2.prototype.linkSync = function(existingPath, newPath) {
          var existingPathFilename = pathToFilename(existingPath);
          var newPathFilename = pathToFilename(newPath);
          this.linkBase(existingPathFilename, newPathFilename);
        };
        Volume2.prototype.link = function(existingPath, newPath, callback) {
          var existingPathFilename = pathToFilename(existingPath);
          var newPathFilename = pathToFilename(newPath);
          this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
        };
        Volume2.prototype.unlinkBase = function(filename) {
          var steps = filenameToSteps(filename);
          var link = this.getLink(steps);
          if (!link)
            throw createError(ENOENT, "unlink", filename);
          if (link.length)
            throw Error("Dir not empty...");
          this.deleteLink(link);
          var node = link.getNode();
          node.nlink--;
          if (node.nlink <= 0) {
            this.deleteNode(node);
          }
        };
        Volume2.prototype.unlinkSync = function(path3) {
          var filename = pathToFilename(path3);
          this.unlinkBase(filename);
        };
        Volume2.prototype.unlink = function(path3, callback) {
          var filename = pathToFilename(path3);
          this.wrapAsync(this.unlinkBase, [filename], callback);
        };
        Volume2.prototype.symlinkBase = function(targetFilename, pathFilename) {
          var pathSteps = filenameToSteps(pathFilename);
          var dirLink = this.getLinkParent(pathSteps);
          if (!dirLink)
            throw createError(ENOENT, "symlink", targetFilename, pathFilename);
          var name = pathSteps[pathSteps.length - 1];
          if (dirLink.getChild(name))
            throw createError(EEXIST, "symlink", targetFilename, pathFilename);
          var symlink = dirLink.createChild(name);
          symlink.getNode().makeSymlink(filenameToSteps(targetFilename));
          return symlink;
        };
        Volume2.prototype.symlinkSync = function(target, path3, type) {
          var targetFilename = pathToFilename(target);
          var pathFilename = pathToFilename(path3);
          this.symlinkBase(targetFilename, pathFilename);
        };
        Volume2.prototype.symlink = function(target, path3, a, b) {
          var callback = validateCallback(typeof a === "function" ? a : b);
          var targetFilename = pathToFilename(target);
          var pathFilename = pathToFilename(path3);
          this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
        };
        Volume2.prototype.realpathBase = function(filename, encoding) {
          var steps = filenameToSteps(filename);
          var realLink = this.getResolvedLink(steps);
          if (!realLink)
            throw createError(ENOENT, "realpath", filename);
          return (0, encoding_1.strToEncoding)(realLink.getPath() || "/", encoding);
        };
        Volume2.prototype.realpathSync = function(path3, options) {
          return this.realpathBase(pathToFilename(path3), getRealpathOptions(options).encoding);
        };
        Volume2.prototype.realpath = function(path3, a, b) {
          var _a2 = getRealpathOptsAndCb(a, b), opts = _a2[0], callback = _a2[1];
          var pathFilename = pathToFilename(path3);
          this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
        };
        Volume2.prototype.lstatBase = function(filename, bigint, throwIfNoEntry) {
          if (bigint === void 0) {
            bigint = false;
          }
          if (throwIfNoEntry === void 0) {
            throwIfNoEntry = false;
          }
          var link = this.getLink(filenameToSteps(filename));
          if (link) {
            return Stats_1.default.build(link.getNode(), bigint);
          } else if (!throwIfNoEntry) {
            return void 0;
          } else {
            throw createError(ENOENT, "lstat", filename);
          }
        };
        Volume2.prototype.lstatSync = function(path3, options) {
          var _a2 = getStatOptions(options), _b = _a2.throwIfNoEntry, throwIfNoEntry = _b === void 0 ? true : _b, _c = _a2.bigint, bigint = _c === void 0 ? false : _c;
          return this.lstatBase(pathToFilename(path3), bigint, throwIfNoEntry);
        };
        Volume2.prototype.lstat = function(path3, a, b) {
          var _a2 = getStatOptsAndCb(a, b), _b = _a2[0], _c = _b.throwIfNoEntry, throwIfNoEntry = _c === void 0 ? true : _c, _d = _b.bigint, bigint = _d === void 0 ? false : _d, callback = _a2[1];
          this.wrapAsync(this.lstatBase, [pathToFilename(path3), bigint, throwIfNoEntry], callback);
        };
        Volume2.prototype.statBase = function(filename, bigint, throwIfNoEntry) {
          if (bigint === void 0) {
            bigint = false;
          }
          if (throwIfNoEntry === void 0) {
            throwIfNoEntry = true;
          }
          var link = this.getResolvedLink(filenameToSteps(filename));
          if (link) {
            return Stats_1.default.build(link.getNode(), bigint);
          } else if (!throwIfNoEntry) {
            return void 0;
          } else {
            throw createError(ENOENT, "stat", filename);
          }
        };
        Volume2.prototype.statSync = function(path3, options) {
          var _a2 = getStatOptions(options), _b = _a2.bigint, bigint = _b === void 0 ? true : _b, _c = _a2.throwIfNoEntry, throwIfNoEntry = _c === void 0 ? true : _c;
          return this.statBase(pathToFilename(path3), bigint, throwIfNoEntry);
        };
        Volume2.prototype.stat = function(path3, a, b) {
          var _a2 = getStatOptsAndCb(a, b), _b = _a2[0], _c = _b.bigint, bigint = _c === void 0 ? false : _c, _d = _b.throwIfNoEntry, throwIfNoEntry = _d === void 0 ? true : _d, callback = _a2[1];
          this.wrapAsync(this.statBase, [pathToFilename(path3), bigint, throwIfNoEntry], callback);
        };
        Volume2.prototype.fstatBase = function(fd, bigint) {
          if (bigint === void 0) {
            bigint = false;
          }
          var file = this.getFileByFd(fd);
          if (!file)
            throw createError(EBADF, "fstat");
          return Stats_1.default.build(file.node, bigint);
        };
        Volume2.prototype.fstatSync = function(fd, options) {
          return this.fstatBase(fd, getStatOptions(options).bigint);
        };
        Volume2.prototype.fstat = function(fd, a, b) {
          var _a2 = getStatOptsAndCb(a, b), opts = _a2[0], callback = _a2[1];
          this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
        };
        Volume2.prototype.renameBase = function(oldPathFilename, newPathFilename) {
          var link = this.getLink(filenameToSteps(oldPathFilename));
          if (!link)
            throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
          var newPathSteps = filenameToSteps(newPathFilename);
          var newPathDirLink = this.getLinkParent(newPathSteps);
          if (!newPathDirLink)
            throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
          var oldLinkParent = link.parent;
          if (oldLinkParent) {
            oldLinkParent.deleteChild(link);
          }
          var name = newPathSteps[newPathSteps.length - 1];
          link.name = name;
          link.steps = __spreadArray(__spreadArray([], newPathDirLink.steps, true), [name], false);
          newPathDirLink.setChild(link.getName(), link);
        };
        Volume2.prototype.renameSync = function(oldPath, newPath) {
          var oldPathFilename = pathToFilename(oldPath);
          var newPathFilename = pathToFilename(newPath);
          this.renameBase(oldPathFilename, newPathFilename);
        };
        Volume2.prototype.rename = function(oldPath, newPath, callback) {
          var oldPathFilename = pathToFilename(oldPath);
          var newPathFilename = pathToFilename(newPath);
          this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
        };
        Volume2.prototype.existsBase = function(filename) {
          return !!this.statBase(filename);
        };
        Volume2.prototype.existsSync = function(path3) {
          try {
            return this.existsBase(pathToFilename(path3));
          } catch (err) {
            return false;
          }
        };
        Volume2.prototype.exists = function(path3, callback) {
          var _this = this;
          var filename = pathToFilename(path3);
          if (typeof callback !== "function")
            throw Error(ERRSTR.CB);
          (0, setImmediate_1.default)(function() {
            try {
              callback(_this.existsBase(filename));
            } catch (err) {
              callback(false);
            }
          });
        };
        Volume2.prototype.accessBase = function(filename, mode) {
          var link = this.getLinkOrThrow(filename, "access");
        };
        Volume2.prototype.accessSync = function(path3, mode) {
          if (mode === void 0) {
            mode = F_OK;
          }
          var filename = pathToFilename(path3);
          mode = mode | 0;
          this.accessBase(filename, mode);
        };
        Volume2.prototype.access = function(path3, a, b) {
          var mode = F_OK;
          var callback;
          if (typeof a !== "function") {
            mode = a | 0;
            callback = validateCallback(b);
          } else {
            callback = a;
          }
          var filename = pathToFilename(path3);
          this.wrapAsync(this.accessBase, [filename, mode], callback);
        };
        Volume2.prototype.appendFileSync = function(id, data, options) {
          if (options === void 0) {
            options = appendFileDefaults;
          }
          var opts = getAppendFileOpts(options);
          if (!opts.flag || isFd(id))
            opts.flag = "a";
          this.writeFileSync(id, data, opts);
        };
        Volume2.prototype.appendFile = function(id, data, a, b) {
          var _a2 = getAppendFileOptsAndCb(a, b), opts = _a2[0], callback = _a2[1];
          if (!opts.flag || isFd(id))
            opts.flag = "a";
          this.writeFile(id, data, opts, callback);
        };
        Volume2.prototype.readdirBase = function(filename, options) {
          var steps = filenameToSteps(filename);
          var link = this.getResolvedLink(steps);
          if (!link)
            throw createError(ENOENT, "readdir", filename);
          var node = link.getNode();
          if (!node.isDirectory())
            throw createError(ENOTDIR, "scandir", filename);
          if (options.withFileTypes) {
            var list_1 = [];
            for (var name_2 in link.children) {
              var child = link.getChild(name_2);
              if (!child || name_2 === "." || name_2 === "..") {
                continue;
              }
              list_1.push(Dirent_1.default.build(child, options.encoding));
            }
            if (!isWin && options.encoding !== "buffer")
              list_1.sort(function(a, b) {
                if (a.name < b.name)
                  return -1;
                if (a.name > b.name)
                  return 1;
                return 0;
              });
            return list_1;
          }
          var list = [];
          for (var name_3 in link.children) {
            if (name_3 === "." || name_3 === "..") {
              continue;
            }
            list.push((0, encoding_1.strToEncoding)(name_3, options.encoding));
          }
          if (!isWin && options.encoding !== "buffer")
            list.sort();
          return list;
        };
        Volume2.prototype.readdirSync = function(path3, options) {
          var opts = getReaddirOptions(options);
          var filename = pathToFilename(path3);
          return this.readdirBase(filename, opts);
        };
        Volume2.prototype.readdir = function(path3, a, b) {
          var _a2 = getReaddirOptsAndCb(a, b), options = _a2[0], callback = _a2[1];
          var filename = pathToFilename(path3);
          this.wrapAsync(this.readdirBase, [filename, options], callback);
        };
        Volume2.prototype.readlinkBase = function(filename, encoding) {
          var link = this.getLinkOrThrow(filename, "readlink");
          var node = link.getNode();
          if (!node.isSymlink())
            throw createError(EINVAL, "readlink", filename);
          var str = sep + node.symlink.join(sep);
          return (0, encoding_1.strToEncoding)(str, encoding);
        };
        Volume2.prototype.readlinkSync = function(path3, options) {
          var opts = getDefaultOpts(options);
          var filename = pathToFilename(path3);
          return this.readlinkBase(filename, opts.encoding);
        };
        Volume2.prototype.readlink = function(path3, a, b) {
          var _a2 = getDefaultOptsAndCb(a, b), opts = _a2[0], callback = _a2[1];
          var filename = pathToFilename(path3);
          this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
        };
        Volume2.prototype.fsyncBase = function(fd) {
          this.getFileByFdOrThrow(fd, "fsync");
        };
        Volume2.prototype.fsyncSync = function(fd) {
          this.fsyncBase(fd);
        };
        Volume2.prototype.fsync = function(fd, callback) {
          this.wrapAsync(this.fsyncBase, [fd], callback);
        };
        Volume2.prototype.fdatasyncBase = function(fd) {
          this.getFileByFdOrThrow(fd, "fdatasync");
        };
        Volume2.prototype.fdatasyncSync = function(fd) {
          this.fdatasyncBase(fd);
        };
        Volume2.prototype.fdatasync = function(fd, callback) {
          this.wrapAsync(this.fdatasyncBase, [fd], callback);
        };
        Volume2.prototype.ftruncateBase = function(fd, len) {
          var file = this.getFileByFdOrThrow(fd, "ftruncate");
          file.truncate(len);
        };
        Volume2.prototype.ftruncateSync = function(fd, len) {
          this.ftruncateBase(fd, len);
        };
        Volume2.prototype.ftruncate = function(fd, a, b) {
          var len = typeof a === "number" ? a : 0;
          var callback = validateCallback(typeof a === "number" ? b : a);
          this.wrapAsync(this.ftruncateBase, [fd, len], callback);
        };
        Volume2.prototype.truncateBase = function(path3, len) {
          var fd = this.openSync(path3, "r+");
          try {
            this.ftruncateSync(fd, len);
          } finally {
            this.closeSync(fd);
          }
        };
        Volume2.prototype.truncateSync = function(id, len) {
          if (isFd(id))
            return this.ftruncateSync(id, len);
          this.truncateBase(id, len);
        };
        Volume2.prototype.truncate = function(id, a, b) {
          var len = typeof a === "number" ? a : 0;
          var callback = validateCallback(typeof a === "number" ? b : a);
          if (isFd(id))
            return this.ftruncate(id, len, callback);
          this.wrapAsync(this.truncateBase, [id, len], callback);
        };
        Volume2.prototype.futimesBase = function(fd, atime, mtime) {
          var file = this.getFileByFdOrThrow(fd, "futimes");
          var node = file.node;
          node.atime = new Date(atime * 1e3);
          node.mtime = new Date(mtime * 1e3);
        };
        Volume2.prototype.futimesSync = function(fd, atime, mtime) {
          this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
        };
        Volume2.prototype.futimes = function(fd, atime, mtime, callback) {
          this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
        };
        Volume2.prototype.utimesBase = function(filename, atime, mtime) {
          var fd = this.openSync(filename, "r");
          try {
            this.futimesBase(fd, atime, mtime);
          } finally {
            this.closeSync(fd);
          }
        };
        Volume2.prototype.utimesSync = function(path3, atime, mtime) {
          this.utimesBase(pathToFilename(path3), toUnixTimestamp(atime), toUnixTimestamp(mtime));
        };
        Volume2.prototype.utimes = function(path3, atime, mtime, callback) {
          this.wrapAsync(this.utimesBase, [pathToFilename(path3), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
        };
        Volume2.prototype.mkdirBase = function(filename, modeNum) {
          var steps = filenameToSteps(filename);
          if (!steps.length) {
            throw createError(EEXIST, "mkdir", filename);
          }
          var dir = this.getLinkParentAsDirOrThrow(filename, "mkdir");
          var name = steps[steps.length - 1];
          if (dir.getChild(name))
            throw createError(EEXIST, "mkdir", filename);
          dir.createChild(name, this.createNode(true, modeNum));
        };
        Volume2.prototype.mkdirpBase = function(filename, modeNum) {
          var fullPath = resolve(filename);
          var fullPathSansSlash = fullPath.substring(1);
          var steps = !fullPathSansSlash ? [] : fullPathSansSlash.split(sep);
          var link = this.root;
          var created = false;
          for (var i = 0; i < steps.length; i++) {
            var step = steps[i];
            if (!link.getNode().isDirectory())
              throw createError(ENOTDIR, "mkdir", link.getPath());
            var child = link.getChild(step);
            if (child) {
              if (child.getNode().isDirectory())
                link = child;
              else
                throw createError(ENOTDIR, "mkdir", child.getPath());
            } else {
              link = link.createChild(step, this.createNode(true, modeNum));
              created = true;
            }
          }
          return created ? fullPath : void 0;
        };
        Volume2.prototype.mkdirSync = function(path3, options) {
          var opts = getMkdirOptions(options);
          var modeNum = modeToNumber(opts.mode, 511);
          var filename = pathToFilename(path3);
          if (opts.recursive)
            return this.mkdirpBase(filename, modeNum);
          this.mkdirBase(filename, modeNum);
        };
        Volume2.prototype.mkdir = function(path3, a, b) {
          var opts = getMkdirOptions(a);
          var callback = validateCallback(typeof a === "function" ? a : b);
          var modeNum = modeToNumber(opts.mode, 511);
          var filename = pathToFilename(path3);
          if (opts.recursive)
            this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
          else
            this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
        };
        Volume2.prototype.mkdirpSync = function(path3, mode) {
          return this.mkdirSync(path3, { mode, recursive: true });
        };
        Volume2.prototype.mkdirp = function(path3, a, b) {
          var mode = typeof a === "function" ? void 0 : a;
          var callback = validateCallback(typeof a === "function" ? a : b);
          this.mkdir(path3, { mode, recursive: true }, callback);
        };
        Volume2.prototype.mkdtempBase = function(prefix, encoding, retry) {
          if (retry === void 0) {
            retry = 5;
          }
          var filename = prefix + this.genRndStr();
          try {
            this.mkdirBase(
              filename,
              511
              /* MODE.DIR */
            );
            return (0, encoding_1.strToEncoding)(filename, encoding);
          } catch (err) {
            if (err.code === EEXIST) {
              if (retry > 1)
                return this.mkdtempBase(prefix, encoding, retry - 1);
              else
                throw Error("Could not create temp dir.");
            } else
              throw err;
          }
        };
        Volume2.prototype.mkdtempSync = function(prefix, options) {
          var encoding = getDefaultOpts(options).encoding;
          if (!prefix || typeof prefix !== "string")
            throw new TypeError("filename prefix is required");
          nullCheck(prefix);
          return this.mkdtempBase(prefix, encoding);
        };
        Volume2.prototype.mkdtemp = function(prefix, a, b) {
          var _a2 = getDefaultOptsAndCb(a, b), encoding = _a2[0].encoding, callback = _a2[1];
          if (!prefix || typeof prefix !== "string")
            throw new TypeError("filename prefix is required");
          if (!nullCheck(prefix))
            return;
          this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
        };
        Volume2.prototype.rmdirBase = function(filename, options) {
          var opts = getRmdirOptions(options);
          var link = this.getLinkAsDirOrThrow(filename, "rmdir");
          if (link.length && !opts.recursive)
            throw createError(ENOTEMPTY, "rmdir", filename);
          this.deleteLink(link);
        };
        Volume2.prototype.rmdirSync = function(path3, options) {
          this.rmdirBase(pathToFilename(path3), options);
        };
        Volume2.prototype.rmdir = function(path3, a, b) {
          var opts = getRmdirOptions(a);
          var callback = validateCallback(typeof a === "function" ? a : b);
          this.wrapAsync(this.rmdirBase, [pathToFilename(path3), opts], callback);
        };
        Volume2.prototype.rmBase = function(filename, options) {
          if (options === void 0) {
            options = {};
          }
          var link = this.getResolvedLink(filename);
          if (!link) {
            if (!options.force)
              throw createError(ENOENT, "stat", filename);
            return;
          }
          if (link.getNode().isDirectory()) {
            if (!options.recursive) {
              throw createError(ERR_FS_EISDIR, "rm", filename);
            }
          }
          this.deleteLink(link);
        };
        Volume2.prototype.rmSync = function(path3, options) {
          this.rmBase(pathToFilename(path3), options);
        };
        Volume2.prototype.rm = function(path3, a, b) {
          var _a2 = getRmOptsAndCb(a, b), opts = _a2[0], callback = _a2[1];
          this.wrapAsync(this.rmBase, [pathToFilename(path3), opts], callback);
        };
        Volume2.prototype.fchmodBase = function(fd, modeNum) {
          var file = this.getFileByFdOrThrow(fd, "fchmod");
          file.chmod(modeNum);
        };
        Volume2.prototype.fchmodSync = function(fd, mode) {
          this.fchmodBase(fd, modeToNumber(mode));
        };
        Volume2.prototype.fchmod = function(fd, mode, callback) {
          this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
        };
        Volume2.prototype.chmodBase = function(filename, modeNum) {
          var fd = this.openSync(filename, "r");
          try {
            this.fchmodBase(fd, modeNum);
          } finally {
            this.closeSync(fd);
          }
        };
        Volume2.prototype.chmodSync = function(path3, mode) {
          var modeNum = modeToNumber(mode);
          var filename = pathToFilename(path3);
          this.chmodBase(filename, modeNum);
        };
        Volume2.prototype.chmod = function(path3, mode, callback) {
          var modeNum = modeToNumber(mode);
          var filename = pathToFilename(path3);
          this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
        };
        Volume2.prototype.lchmodBase = function(filename, modeNum) {
          var fd = this.openBase(filename, O_RDWR, 0, false);
          try {
            this.fchmodBase(fd, modeNum);
          } finally {
            this.closeSync(fd);
          }
        };
        Volume2.prototype.lchmodSync = function(path3, mode) {
          var modeNum = modeToNumber(mode);
          var filename = pathToFilename(path3);
          this.lchmodBase(filename, modeNum);
        };
        Volume2.prototype.lchmod = function(path3, mode, callback) {
          var modeNum = modeToNumber(mode);
          var filename = pathToFilename(path3);
          this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
        };
        Volume2.prototype.fchownBase = function(fd, uid, gid) {
          this.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
        };
        Volume2.prototype.fchownSync = function(fd, uid, gid) {
          validateUid(uid);
          validateGid(gid);
          this.fchownBase(fd, uid, gid);
        };
        Volume2.prototype.fchown = function(fd, uid, gid, callback) {
          validateUid(uid);
          validateGid(gid);
          this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
        };
        Volume2.prototype.chownBase = function(filename, uid, gid) {
          var link = this.getResolvedLinkOrThrow(filename, "chown");
          var node = link.getNode();
          node.chown(uid, gid);
        };
        Volume2.prototype.chownSync = function(path3, uid, gid) {
          validateUid(uid);
          validateGid(gid);
          this.chownBase(pathToFilename(path3), uid, gid);
        };
        Volume2.prototype.chown = function(path3, uid, gid, callback) {
          validateUid(uid);
          validateGid(gid);
          this.wrapAsync(this.chownBase, [pathToFilename(path3), uid, gid], callback);
        };
        Volume2.prototype.lchownBase = function(filename, uid, gid) {
          this.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
        };
        Volume2.prototype.lchownSync = function(path3, uid, gid) {
          validateUid(uid);
          validateGid(gid);
          this.lchownBase(pathToFilename(path3), uid, gid);
        };
        Volume2.prototype.lchown = function(path3, uid, gid, callback) {
          validateUid(uid);
          validateGid(gid);
          this.wrapAsync(this.lchownBase, [pathToFilename(path3), uid, gid], callback);
        };
        Volume2.prototype.watchFile = function(path3, a, b) {
          var filename = pathToFilename(path3);
          var options = a;
          var listener = b;
          if (typeof options === "function") {
            listener = a;
            options = null;
          }
          if (typeof listener !== "function") {
            throw Error('"watchFile()" requires a listener function');
          }
          var interval = 5007;
          var persistent = true;
          if (options && typeof options === "object") {
            if (typeof options.interval === "number")
              interval = options.interval;
            if (typeof options.persistent === "boolean")
              persistent = options.persistent;
          }
          var watcher = this.statWatchers[filename];
          if (!watcher) {
            watcher = new this.StatWatcher();
            watcher.start(filename, persistent, interval);
            this.statWatchers[filename] = watcher;
          }
          watcher.addListener("change", listener);
          return watcher;
        };
        Volume2.prototype.unwatchFile = function(path3, listener) {
          var filename = pathToFilename(path3);
          var watcher = this.statWatchers[filename];
          if (!watcher)
            return;
          if (typeof listener === "function") {
            watcher.removeListener("change", listener);
          } else {
            watcher.removeAllListeners("change");
          }
          if (watcher.listenerCount("change") === 0) {
            watcher.stop();
            delete this.statWatchers[filename];
          }
        };
        Volume2.prototype.createReadStream = function(path3, options) {
          return new this.ReadStream(path3, options);
        };
        Volume2.prototype.createWriteStream = function(path3, options) {
          return new this.WriteStream(path3, options);
        };
        Volume2.prototype.watch = function(path3, options, listener) {
          var filename = pathToFilename(path3);
          var givenOptions = options;
          if (typeof options === "function") {
            listener = options;
            givenOptions = null;
          }
          var _a2 = getDefaultOpts(givenOptions), persistent = _a2.persistent, recursive = _a2.recursive, encoding = _a2.encoding;
          if (persistent === void 0)
            persistent = true;
          if (recursive === void 0)
            recursive = false;
          var watcher = new this.FSWatcher();
          watcher.start(filename, persistent, recursive, encoding);
          if (listener) {
            watcher.addListener("change", listener);
          }
          return watcher;
        };
        Volume2.fd = 2147483647;
        return Volume2;
      }()
    );
    exports2.Volume = Volume;
    function emitStop(self) {
      self.emit("stop");
    }
    var StatWatcher = (
      /** @class */
      function(_super) {
        __extends(StatWatcher2, _super);
        function StatWatcher2(vol) {
          var _this = _super.call(this) || this;
          _this.onInterval = function() {
            try {
              var stats = _this.vol.statSync(_this.filename);
              if (_this.hasChanged(stats)) {
                _this.emit("change", stats, _this.prev);
                _this.prev = stats;
              }
            } finally {
              _this.loop();
            }
          };
          _this.vol = vol;
          return _this;
        }
        StatWatcher2.prototype.loop = function() {
          this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
        };
        StatWatcher2.prototype.hasChanged = function(stats) {
          if (stats.mtimeMs > this.prev.mtimeMs)
            return true;
          if (stats.nlink !== this.prev.nlink)
            return true;
          return false;
        };
        StatWatcher2.prototype.start = function(path3, persistent, interval) {
          if (persistent === void 0) {
            persistent = true;
          }
          if (interval === void 0) {
            interval = 5007;
          }
          this.filename = pathToFilename(path3);
          this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : global) : setTimeoutUnref_1.default;
          this.interval = interval;
          this.prev = this.vol.statSync(this.filename);
          this.loop();
        };
        StatWatcher2.prototype.stop = function() {
          clearTimeout(this.timeoutRef);
          process_1.default.nextTick(emitStop, this);
        };
        return StatWatcher2;
      }(events_1.EventEmitter)
    );
    exports2.StatWatcher = StatWatcher;
    var pool;
    function allocNewPool(poolSize) {
      pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
      pool.used = 0;
    }
    util.inherits(FsReadStream, stream_1.Readable);
    exports2.ReadStream = FsReadStream;
    function FsReadStream(vol, path3, options) {
      if (!(this instanceof FsReadStream))
        return new FsReadStream(vol, path3, options);
      this._vol = vol;
      options = Object.assign({}, getOptions(options, {}));
      if (options.highWaterMark === void 0)
        options.highWaterMark = 64 * 1024;
      stream_1.Readable.call(this, options);
      this.path = pathToFilename(path3);
      this.fd = options.fd === void 0 ? null : options.fd;
      this.flags = options.flags === void 0 ? "r" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.end = options.end;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = void 0;
      this.bytesRead = 0;
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw new TypeError('"start" option must be a Number');
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if (typeof this.end !== "number") {
          throw new TypeError('"end" option must be a Number');
        }
        if (this.start > this.end) {
          throw new Error('"start" option must be <= "end" option');
        }
        this.pos = this.start;
      }
      if (typeof this.fd !== "number")
        this.open();
      this.on("end", function() {
        if (this.autoClose) {
          if (this.destroy)
            this.destroy();
        }
      });
    }
    FsReadStream.prototype.open = function() {
      var self = this;
      this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
        if (er) {
          if (self.autoClose) {
            if (self.destroy)
              self.destroy();
          }
          self.emit("error", er);
          return;
        }
        self.fd = fd;
        self.emit("open", fd);
        self.read();
      });
    };
    FsReadStream.prototype._read = function(n) {
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._read(n);
        });
      }
      if (this.destroyed)
        return;
      if (!pool || pool.length - pool.used < kMinPoolSpace) {
        allocNewPool(this._readableState.highWaterMark);
      }
      var thisPool = pool;
      var toRead = Math.min(pool.length - pool.used, n);
      var start = pool.used;
      if (this.pos !== void 0)
        toRead = Math.min(this.end - this.pos + 1, toRead);
      if (toRead <= 0)
        return this.push(null);
      var self = this;
      this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
      if (this.pos !== void 0)
        this.pos += toRead;
      pool.used += toRead;
      function onread(er, bytesRead) {
        if (er) {
          if (self.autoClose && self.destroy) {
            self.destroy();
          }
          self.emit("error", er);
        } else {
          var b = null;
          if (bytesRead > 0) {
            self.bytesRead += bytesRead;
            b = thisPool.slice(start, start + bytesRead);
          }
          self.push(b);
        }
      }
    };
    FsReadStream.prototype._destroy = function(err, cb) {
      this.close(function(err2) {
        cb(err || err2);
      });
    };
    FsReadStream.prototype.close = function(cb) {
      var _this = this;
      var _a2;
      if (cb)
        this.once("close", cb);
      if (this.closed || typeof this.fd !== "number") {
        if (typeof this.fd !== "number") {
          this.once("open", closeOnOpen);
          return;
        }
        return process_1.default.nextTick(function() {
          return _this.emit("close");
        });
      }
      if (typeof ((_a2 = this._readableState) === null || _a2 === void 0 ? void 0 : _a2.closed) === "boolean") {
        this._readableState.closed = true;
      } else {
        this.closed = true;
      }
      this._vol.close(this.fd, function(er) {
        if (er)
          _this.emit("error", er);
        else
          _this.emit("close");
      });
      this.fd = null;
    };
    function closeOnOpen(fd) {
      this.close();
    }
    util.inherits(FsWriteStream, stream_1.Writable);
    exports2.WriteStream = FsWriteStream;
    function FsWriteStream(vol, path3, options) {
      if (!(this instanceof FsWriteStream))
        return new FsWriteStream(vol, path3, options);
      this._vol = vol;
      options = Object.assign({}, getOptions(options, {}));
      stream_1.Writable.call(this, options);
      this.path = pathToFilename(path3);
      this.fd = options.fd === void 0 ? null : options.fd;
      this.flags = options.flags === void 0 ? "w" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.autoClose = options.autoClose === void 0 ? true : !!options.autoClose;
      this.pos = void 0;
      this.bytesWritten = 0;
      if (this.start !== void 0) {
        if (typeof this.start !== "number") {
          throw new TypeError('"start" option must be a Number');
        }
        if (this.start < 0) {
          throw new Error('"start" must be >= zero');
        }
        this.pos = this.start;
      }
      if (options.encoding)
        this.setDefaultEncoding(options.encoding);
      if (typeof this.fd !== "number")
        this.open();
      this.once("finish", function() {
        if (this.autoClose) {
          this.close();
        }
      });
    }
    FsWriteStream.prototype.open = function() {
      this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
        if (er) {
          if (this.autoClose && this.destroy) {
            this.destroy();
          }
          this.emit("error", er);
          return;
        }
        this.fd = fd;
        this.emit("open", fd);
      }.bind(this));
    };
    FsWriteStream.prototype._write = function(data, encoding, cb) {
      if (!(data instanceof buffer_1.Buffer || data instanceof Uint8Array))
        return this.emit("error", new Error("Invalid data"));
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._write(data, encoding, cb);
        });
      }
      var self = this;
      this._vol.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {
        if (er) {
          if (self.autoClose && self.destroy) {
            self.destroy();
          }
          return cb(er);
        }
        self.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0)
        this.pos += data.length;
    };
    FsWriteStream.prototype._writev = function(data, cb) {
      if (typeof this.fd !== "number") {
        return this.once("open", function() {
          this._writev(data, cb);
        });
      }
      var self = this;
      var len = data.length;
      var chunks = new Array(len);
      var size = 0;
      for (var i = 0; i < len; i++) {
        var chunk = data[i].chunk;
        chunks[i] = chunk;
        size += chunk.length;
      }
      var buf = buffer_1.Buffer.concat(chunks);
      this._vol.write(this.fd, buf, 0, buf.length, this.pos, function(er, bytes) {
        if (er) {
          if (self.destroy)
            self.destroy();
          return cb(er);
        }
        self.bytesWritten += bytes;
        cb();
      });
      if (this.pos !== void 0)
        this.pos += size;
    };
    FsWriteStream.prototype.close = function(cb) {
      var _this = this;
      var _a2;
      if (cb)
        this.once("close", cb);
      if (this.closed || typeof this.fd !== "number") {
        if (typeof this.fd !== "number") {
          this.once("open", closeOnOpen);
          return;
        }
        return process_1.default.nextTick(function() {
          return _this.emit("close");
        });
      }
      if (typeof ((_a2 = this._writableState) === null || _a2 === void 0 ? void 0 : _a2.closed) === "boolean") {
        this._writableState.closed = true;
      } else {
        this.closed = true;
      }
      this._vol.close(this.fd, function(er) {
        if (er)
          _this.emit("error", er);
        else
          _this.emit("close");
      });
      this.fd = null;
    };
    FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
    FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
    var FSWatcher = (
      /** @class */
      function(_super) {
        __extends(FSWatcher2, _super);
        function FSWatcher2(vol) {
          var _this = _super.call(this) || this;
          _this._filename = "";
          _this._filenameEncoded = "";
          _this._recursive = false;
          _this._encoding = encoding_1.ENCODING_UTF8;
          _this._listenerRemovers = /* @__PURE__ */ new Map();
          _this._onParentChild = function(link) {
            if (link.getName() === _this._getName()) {
              _this._emit("rename");
            }
          };
          _this._emit = function(type) {
            _this.emit("change", type, _this._filenameEncoded);
          };
          _this._persist = function() {
            _this._timer = setTimeout(_this._persist, 1e6);
          };
          _this._vol = vol;
          return _this;
        }
        FSWatcher2.prototype._getName = function() {
          return this._steps[this._steps.length - 1];
        };
        FSWatcher2.prototype.start = function(path3, persistent, recursive, encoding) {
          var _this = this;
          if (persistent === void 0) {
            persistent = true;
          }
          if (recursive === void 0) {
            recursive = false;
          }
          if (encoding === void 0) {
            encoding = encoding_1.ENCODING_UTF8;
          }
          this._filename = pathToFilename(path3);
          this._steps = filenameToSteps(this._filename);
          this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
          this._recursive = recursive;
          this._encoding = encoding;
          try {
            this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
          } catch (err) {
            var error = new Error("watch ".concat(this._filename, " ").concat(err.code));
            error.code = err.code;
            error.errno = err.code;
            throw error;
          }
          var watchLinkNodeChanged = function(link) {
            var _a2;
            var filepath = link.getPath();
            var node = link.getNode();
            var onNodeChange = function() {
              var filename = relative(_this._filename, filepath);
              if (!filename) {
                filename = _this._getName();
              }
              return _this.emit("change", "change", filename);
            };
            node.on("change", onNodeChange);
            var removers = (_a2 = _this._listenerRemovers.get(node.ino)) !== null && _a2 !== void 0 ? _a2 : [];
            removers.push(function() {
              return node.removeListener("change", onNodeChange);
            });
            _this._listenerRemovers.set(node.ino, removers);
          };
          var watchLinkChildrenChanged = function(link) {
            var _a2;
            var node = link.getNode();
            var onLinkChildAdd = function(l) {
              _this.emit("change", "rename", relative(_this._filename, l.getPath()));
              setTimeout(function() {
                watchLinkNodeChanged(l);
                watchLinkChildrenChanged(l);
              });
            };
            var onLinkChildDelete = function(l) {
              var removeLinkNodeListeners = function(curLink) {
                var ino = curLink.getNode().ino;
                var removers2 = _this._listenerRemovers.get(ino);
                if (removers2) {
                  removers2.forEach(function(r) {
                    return r();
                  });
                  _this._listenerRemovers.delete(ino);
                }
                Object.values(curLink.children).forEach(function(childLink) {
                  if (childLink) {
                    removeLinkNodeListeners(childLink);
                  }
                });
              };
              removeLinkNodeListeners(l);
              _this.emit("change", "rename", relative(_this._filename, l.getPath()));
            };
            Object.entries(link.children).forEach(function(_a3) {
              var name = _a3[0], childLink = _a3[1];
              if (childLink && name !== "." && name !== "..") {
                watchLinkNodeChanged(childLink);
              }
            });
            link.on("child:add", onLinkChildAdd);
            link.on("child:delete", onLinkChildDelete);
            var removers = (_a2 = _this._listenerRemovers.get(node.ino)) !== null && _a2 !== void 0 ? _a2 : [];
            removers.push(function() {
              link.removeListener("child:add", onLinkChildAdd);
              link.removeListener("child:delete", onLinkChildDelete);
            });
            if (recursive) {
              Object.entries(link.children).forEach(function(_a3) {
                var name = _a3[0], childLink = _a3[1];
                if (childLink && name !== "." && name !== "..") {
                  watchLinkChildrenChanged(childLink);
                }
              });
            }
          };
          watchLinkNodeChanged(this._link);
          watchLinkChildrenChanged(this._link);
          var parent = this._link.parent;
          if (parent) {
            parent.setMaxListeners(parent.getMaxListeners() + 1);
            parent.on("child:delete", this._onParentChild);
          }
          if (persistent)
            this._persist();
        };
        FSWatcher2.prototype.close = function() {
          clearTimeout(this._timer);
          this._listenerRemovers.forEach(function(removers) {
            removers.forEach(function(r) {
              return r();
            });
          });
          this._listenerRemovers.clear();
          var parent = this._link.parent;
          if (parent) {
            parent.removeListener("child:delete", this._onParentChild);
          }
        };
        return FSWatcher2;
      }(events_1.EventEmitter)
    );
    exports2.FSWatcher = FSWatcher;
  }
});

// ../../node_modules/.pnpm/fs-monkey@1.0.6/node_modules/fs-monkey/lib/util/lists.js
var require_lists = __commonJS({
  "../../node_modules/.pnpm/fs-monkey@1.0.6/node_modules/fs-monkey/lib/util/lists.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.fsSyncMethods = exports2.fsProps = exports2.fsAsyncMethods = void 0;
    var fsProps = exports2.fsProps = ["constants", "F_OK", "R_OK", "W_OK", "X_OK", "Stats"];
    var fsSyncMethods = exports2.fsSyncMethods = ["renameSync", "ftruncateSync", "truncateSync", "chownSync", "fchownSync", "lchownSync", "chmodSync", "fchmodSync", "lchmodSync", "statSync", "lstatSync", "fstatSync", "linkSync", "symlinkSync", "readlinkSync", "realpathSync", "unlinkSync", "rmdirSync", "mkdirSync", "mkdirpSync", "readdirSync", "closeSync", "openSync", "utimesSync", "futimesSync", "fsyncSync", "writeSync", "readSync", "readFileSync", "writeFileSync", "appendFileSync", "existsSync", "accessSync", "fdatasyncSync", "mkdtempSync", "copyFileSync", "rmSync", "createReadStream", "createWriteStream"];
    var fsAsyncMethods = exports2.fsAsyncMethods = ["rename", "ftruncate", "truncate", "chown", "fchown", "lchown", "chmod", "fchmod", "lchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "mkdirp", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "exists", "access", "fdatasync", "mkdtemp", "copyFile", "rm", "watchFile", "unwatchFile", "watch"];
  }
});

// ../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/index.js
var require_lib = __commonJS({
  "../../node_modules/.pnpm/memfs@3.5.3/node_modules/memfs/lib/index.js"(exports2, module2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fs = exports2.createFsFromVolume = exports2.vol = exports2.Volume = void 0;
    var Stats_1 = require_Stats();
    var Dirent_1 = require_Dirent();
    var volume_1 = require_volume();
    var _a = require_lists();
    var fsSyncMethods = _a.fsSyncMethods;
    var fsAsyncMethods = _a.fsAsyncMethods;
    var constants_1 = require_constants();
    var F_OK = constants_1.constants.F_OK;
    var R_OK = constants_1.constants.R_OK;
    var W_OK = constants_1.constants.W_OK;
    var X_OK = constants_1.constants.X_OK;
    exports2.Volume = volume_1.Volume;
    exports2.vol = new volume_1.Volume();
    function createFsFromVolume(vol) {
      var fs = { F_OK, R_OK, W_OK, X_OK, constants: constants_1.constants, Stats: Stats_1.default, Dirent: Dirent_1.default };
      for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
        var method = fsSyncMethods_1[_i];
        if (typeof vol[method] === "function")
          fs[method] = vol[method].bind(vol);
      }
      for (var _a2 = 0, fsAsyncMethods_1 = fsAsyncMethods; _a2 < fsAsyncMethods_1.length; _a2++) {
        var method = fsAsyncMethods_1[_a2];
        if (typeof vol[method] === "function")
          fs[method] = vol[method].bind(vol);
      }
      fs.StatWatcher = vol.StatWatcher;
      fs.FSWatcher = vol.FSWatcher;
      fs.WriteStream = vol.WriteStream;
      fs.ReadStream = vol.ReadStream;
      fs.promises = vol.promises;
      fs._toUnixTimestamp = volume_1.toUnixTimestamp;
      return fs;
    }
    exports2.createFsFromVolume = createFsFromVolume;
    exports2.fs = createFsFromVolume(exports2.vol);
    module2.exports = __assign(__assign({}, module2.exports), exports2.fs);
    module2.exports.semantic = true;
  }
});

// ../../node_modules/.pnpm/unionfs@4.5.4/node_modules/unionfs/lib/union.js
var require_union = __commonJS({
  "../../node_modules/.pnpm/unionfs@4.5.4/node_modules/unionfs/lib/union.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1) throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }
              if (t && _.label < t[2]) {
                _.label = t[2];
                _.ops.push(op);
                break;
              }
              if (t[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Union = void 0;
    var path_1 = require("path");
    var stream_1 = require("stream");
    var _a = require_lists();
    var fsAsyncMethods = _a.fsAsyncMethods;
    var fsSyncMethods = _a.fsSyncMethods;
    var SPECIAL_METHODS = /* @__PURE__ */ new Set([
      "existsSync",
      "readdir",
      "readdirSync",
      "createReadStream",
      "createWriteStream",
      "watch",
      "watchFile",
      "unwatchFile"
    ]);
    var createFSProxy = function(watchers) {
      return new Proxy({}, {
        get: function(_obj, property) {
          var e_1, _a2;
          var funcCallers = [];
          var prop;
          try {
            for (var watchers_1 = __values(watchers), watchers_1_1 = watchers_1.next(); !watchers_1_1.done; watchers_1_1 = watchers_1.next()) {
              var watcher = watchers_1_1.value;
              prop = watcher[property];
              if (typeof prop === "function") {
                funcCallers.push([watcher, prop]);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (watchers_1_1 && !watchers_1_1.done && (_a2 = watchers_1.return)) _a2.call(watchers_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          if (funcCallers.length) {
            return function() {
              var e_2, _a3;
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              try {
                for (var funcCallers_1 = __values(funcCallers), funcCallers_1_1 = funcCallers_1.next(); !funcCallers_1_1.done; funcCallers_1_1 = funcCallers_1.next()) {
                  var _b = __read(funcCallers_1_1.value, 2), watcher2 = _b[0], func = _b[1];
                  func.apply(watcher2, args);
                }
              } catch (e_2_1) {
                e_2 = { error: e_2_1 };
              } finally {
                try {
                  if (funcCallers_1_1 && !funcCallers_1_1.done && (_a3 = funcCallers_1.return)) _a3.call(funcCallers_1);
                } finally {
                  if (e_2) throw e_2.error;
                }
              }
            };
          } else {
            return prop;
          }
        }
      });
    };
    var fsPromisesMethods = [
      "access",
      "copyFile",
      "open",
      "opendir",
      "rename",
      "truncate",
      "rmdir",
      "mkdir",
      "readdir",
      "readlink",
      "symlink",
      "lstat",
      "stat",
      "link",
      "unlink",
      "chmod",
      "lchmod",
      "lchown",
      "chown",
      "utimes",
      "realpath",
      "mkdtemp",
      "writeFile",
      "appendFile",
      "readFile"
    ];
    var Union = (
      /** @class */
      function() {
        function Union2() {
          var e_3, _a2, e_4, _b, e_5, _c, e_6, _d;
          var _this = this;
          this.fss = [];
          this.ReadStream = stream_1.Readable;
          this.WriteStream = stream_1.Writable;
          this.promises = {};
          this.unwatchFile = function() {
            var e_7, _a3;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            try {
              for (var _b2 = __values(_this.fss), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
                var fs = _c2.value;
                try {
                  fs.unwatchFile.apply(fs, args);
                } catch (e) {
                }
              }
            } catch (e_7_1) {
              e_7 = { error: e_7_1 };
            } finally {
              try {
                if (_c2 && !_c2.done && (_a3 = _b2.return)) _a3.call(_b2);
              } finally {
                if (e_7) throw e_7.error;
              }
            }
          };
          this.watch = function() {
            var e_8, _a3;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var watchers = [];
            try {
              for (var _b2 = __values(_this.fss), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
                var fs = _c2.value;
                try {
                  var watcher = fs.watch.apply(fs, args);
                  watchers.push(watcher);
                } catch (e) {
                }
              }
            } catch (e_8_1) {
              e_8 = { error: e_8_1 };
            } finally {
              try {
                if (_c2 && !_c2.done && (_a3 = _b2.return)) _a3.call(_b2);
              } finally {
                if (e_8) throw e_8.error;
              }
            }
            return createFSProxy(watchers);
          };
          this.watchFile = function() {
            var e_9, _a3;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            try {
              for (var _b2 = __values(_this.fss), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
                var fs = _c2.value;
                try {
                  fs.watchFile.apply(fs, args);
                } catch (e) {
                }
              }
            } catch (e_9_1) {
              e_9 = { error: e_9_1 };
            } finally {
              try {
                if (_c2 && !_c2.done && (_a3 = _b2.return)) _a3.call(_b2);
              } finally {
                if (e_9) throw e_9.error;
              }
            }
          };
          this.existsSync = function(path3) {
            var e_10, _a3;
            try {
              for (var _b2 = __values(_this.fss), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
                var fs = _c2.value;
                try {
                  if (fs.existsSync(path3)) {
                    return true;
                  }
                } catch (e) {
                }
              }
            } catch (e_10_1) {
              e_10 = { error: e_10_1 };
            } finally {
              try {
                if (_c2 && !_c2.done && (_a3 = _b2.return)) _a3.call(_b2);
              } finally {
                if (e_10) throw e_10.error;
              }
            }
            return false;
          };
          this.readdir = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var lastarg = args.length - 1;
            var cb = args[lastarg];
            if (typeof cb !== "function") {
              cb = null;
              lastarg++;
            }
            var numErrors = 0;
            var lastError = null;
            var result = /* @__PURE__ */ new Map();
            var iterate = function(i, error) {
              if (i === void 0) {
                i = 0;
              }
              if (error) {
                error.prev = lastError;
                lastError = error;
                numErrors++;
              }
              if (i >= _this.fss.length) {
                if (cb) {
                  if (numErrors < _this.fss.length) {
                    return cb(null, _this.sortedArrayFromReaddirResult(result));
                  }
                  cb(error || Error("No file systems attached."));
                }
                return;
              }
              args[lastarg] = function(err, resArg) {
                var e_11, _a3;
                if (resArg) {
                  try {
                    for (var resArg_1 = __values(resArg), resArg_1_1 = resArg_1.next(); !resArg_1_1.done; resArg_1_1 = resArg_1.next()) {
                      var res = resArg_1_1.value;
                      result.set(_this.pathFromReaddirEntry(res), res);
                    }
                  } catch (e_11_1) {
                    e_11 = { error: e_11_1 };
                  } finally {
                    try {
                      if (resArg_1_1 && !resArg_1_1.done && (_a3 = resArg_1.return)) _a3.call(resArg_1);
                    } finally {
                      if (e_11) throw e_11.error;
                    }
                  }
                }
                return iterate(i + 1, err);
              };
              var j = _this.fss.length - i - 1;
              var fs = _this.fss[j];
              var func = fs.readdir;
              if (!func)
                iterate(i + 1, Error("Method not supported: readdir"));
              else
                func.apply(fs, args);
            };
            iterate();
          };
          this.readdirSync = function() {
            var e_12, _a3;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var numErrors = 0;
            var lastError = null;
            var result = /* @__PURE__ */ new Map();
            for (var i = _this.fss.length - 1; i >= 0; i--) {
              var fs = _this.fss[i];
              try {
                if (!fs.readdirSync)
                  throw Error('Method not supported: "readdirSync" with args "'.concat(args, '"'));
                try {
                  for (var _b2 = (e_12 = void 0, __values(fs.readdirSync.apply(fs, args))), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
                    var res = _c2.value;
                    result.set(_this.pathFromReaddirEntry(res), res);
                  }
                } catch (e_12_1) {
                  e_12 = { error: e_12_1 };
                } finally {
                  try {
                    if (_c2 && !_c2.done && (_a3 = _b2.return)) _a3.call(_b2);
                  } finally {
                    if (e_12) throw e_12.error;
                  }
                }
              } catch (err) {
                err.prev = lastError;
                lastError = err;
                numErrors++;
                if (numErrors === _this.fss.length) {
                  throw err;
                } else {
                }
              }
            }
            return _this.sortedArrayFromReaddirResult(result);
          };
          this.readdirPromise = function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return __awaiter(_this, void 0, void 0, function() {
              var lastError, result, i, fs, _a3, _b2, res, e_13_1, err_1;
              var e_13, _c2;
              return __generator(this, function(_d2) {
                switch (_d2.label) {
                  case 0:
                    lastError = null;
                    result = /* @__PURE__ */ new Map();
                    i = this.fss.length - 1;
                    _d2.label = 1;
                  case 1:
                    if (!(i >= 0)) return [3, 13];
                    fs = this.fss[i];
                    _d2.label = 2;
                  case 2:
                    _d2.trys.push([2, 11, , 12]);
                    if (!fs.promises || !fs.promises.readdir)
                      throw Error('Method not supported: "readdirSync" with args "'.concat(args, '"'));
                    _d2.label = 3;
                  case 3:
                    _d2.trys.push([3, 8, 9, 10]);
                    e_13 = void 0;
                    return [4, fs.promises.readdir.apply(fs, args)];
                  case 4:
                    _a3 = __values.apply(void 0, [_d2.sent()]), _b2 = _a3.next();
                    _d2.label = 5;
                  case 5:
                    if (!!_b2.done) return [3, 7];
                    res = _b2.value;
                    result.set(this.pathFromReaddirEntry(res), res);
                    _d2.label = 6;
                  case 6:
                    _b2 = _a3.next();
                    return [3, 5];
                  case 7:
                    return [3, 10];
                  case 8:
                    e_13_1 = _d2.sent();
                    e_13 = { error: e_13_1 };
                    return [3, 10];
                  case 9:
                    try {
                      if (_b2 && !_b2.done && (_c2 = _a3.return)) _c2.call(_a3);
                    } finally {
                      if (e_13) throw e_13.error;
                    }
                    return [
                      7
                      /*endfinally*/
                    ];
                  case 10:
                    return [3, 12];
                  case 11:
                    err_1 = _d2.sent();
                    err_1.prev = lastError;
                    lastError = err_1;
                    if (result.size === 0 && !i) {
                      throw err_1;
                    } else {
                    }
                    return [3, 12];
                  case 12:
                    i--;
                    return [3, 1];
                  case 13:
                    return [2, this.sortedArrayFromReaddirResult(result)];
                }
              });
            });
          };
          this.pathFromReaddirEntry = function(readdirEntry) {
            if (readdirEntry instanceof Buffer || typeof readdirEntry === "string") {
              return String(readdirEntry);
            }
            return readdirEntry.name;
          };
          this.sortedArrayFromReaddirResult = function(readdirResult) {
            var e_14, _a3;
            var array = [];
            try {
              for (var _b2 = __values(Array.from(readdirResult.keys()).sort()), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
                var key = _c2.value;
                var value = readdirResult.get(key);
                if (value !== void 0)
                  array.push(value);
              }
            } catch (e_14_1) {
              e_14 = { error: e_14_1 };
            } finally {
              try {
                if (_c2 && !_c2.done && (_a3 = _b2.return)) _a3.call(_b2);
              } finally {
                if (e_14) throw e_14.error;
              }
            }
            return array;
          };
          this.createReadStream = function(path3) {
            var lastError = null;
            for (var i = _this.fss.length - 1; i >= 0; i--) {
              var fs = _this.fss[i];
              try {
                if (!fs.createReadStream)
                  throw Error('Method not supported: "createReadStream"');
                if (fs.existsSync && !fs.existsSync(path3)) {
                  throw new Error('file "'.concat(path3, '" does not exists'));
                }
                var stream = fs.createReadStream(path3);
                if (!stream) {
                  throw new Error("no valid stream");
                }
                _this.ReadStream = fs.ReadStream;
                return stream;
              } catch (err) {
                lastError = err;
              }
            }
            throw lastError;
          };
          this.createWriteStream = function(path3) {
            var e_15, _a3;
            var lastError = null;
            var fssWithFilePath = [];
            var fssWithParentDir = [];
            for (var i = _this.fss.length - 1; i >= 0; i--) {
              var fs = _this.fss[i];
              try {
                if (!fs.createWriteStream)
                  throw Error('Method not supported: "createWriteStream"');
                if (!fs.statSync((0, path_1.dirname)(path3)).isDirectory()) {
                  throw new Error('path "'.concat((0, path_1.dirname)(path3), '" is not a directory'));
                }
                if (fs.existsSync(path3)) {
                  fssWithFilePath.push(fs);
                } else {
                  fssWithParentDir.push(fs);
                }
              } catch (err) {
                lastError = err;
              }
            }
            try {
              for (var _b2 = __values(__spreadArray(__spreadArray([], __read(fssWithFilePath), false), __read(fssWithParentDir), false)), _c2 = _b2.next(); !_c2.done; _c2 = _b2.next()) {
                var fs = _c2.value;
                try {
                  var stream = fs.createWriteStream(path3);
                  if (!stream) {
                    throw new Error("no valid stream");
                  }
                  _this.WriteStream = fs.WriteStream;
                  return stream;
                } catch (err) {
                  lastError = err;
                }
              }
            } catch (e_15_1) {
              e_15 = { error: e_15_1 };
            } finally {
              try {
                if (_c2 && !_c2.done && (_a3 = _b2.return)) _a3.call(_b2);
              } finally {
                if (e_15) throw e_15.error;
              }
            }
            throw lastError;
          };
          var _loop_1 = function(method2) {
            if (!SPECIAL_METHODS.has(method2)) {
              this_1[method2] = function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                return _this.syncMethod(method2, args);
              };
            }
          };
          var this_1 = this;
          try {
            for (var fsSyncMethods_1 = __values(fsSyncMethods), fsSyncMethods_1_1 = fsSyncMethods_1.next(); !fsSyncMethods_1_1.done; fsSyncMethods_1_1 = fsSyncMethods_1.next()) {
              var method = fsSyncMethods_1_1.value;
              _loop_1(method);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (fsSyncMethods_1_1 && !fsSyncMethods_1_1.done && (_a2 = fsSyncMethods_1.return)) _a2.call(fsSyncMethods_1);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
          var _loop_2 = function(method2) {
            if (!SPECIAL_METHODS.has(method2)) {
              this_2[method2] = function() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                return _this.asyncMethod(method2, args);
              };
            }
          };
          var this_2 = this;
          try {
            for (var fsAsyncMethods_1 = __values(fsAsyncMethods), fsAsyncMethods_1_1 = fsAsyncMethods_1.next(); !fsAsyncMethods_1_1.done; fsAsyncMethods_1_1 = fsAsyncMethods_1.next()) {
              var method = fsAsyncMethods_1_1.value;
              _loop_2(method);
            }
          } catch (e_4_1) {
            e_4 = { error: e_4_1 };
          } finally {
            try {
              if (fsAsyncMethods_1_1 && !fsAsyncMethods_1_1.done && (_b = fsAsyncMethods_1.return)) _b.call(fsAsyncMethods_1);
            } finally {
              if (e_4) throw e_4.error;
            }
          }
          var _loop_3 = function(method2) {
            if (method2 === "readdir") {
              this_3.promises[method2] = this_3.readdirPromise;
              return "continue";
            }
            this_3.promises[method2] = function() {
              var args = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              return _this.promiseMethod(method2, args);
            };
          };
          var this_3 = this;
          try {
            for (var fsPromisesMethods_1 = __values(fsPromisesMethods), fsPromisesMethods_1_1 = fsPromisesMethods_1.next(); !fsPromisesMethods_1_1.done; fsPromisesMethods_1_1 = fsPromisesMethods_1.next()) {
              var method = fsPromisesMethods_1_1.value;
              _loop_3(method);
            }
          } catch (e_5_1) {
            e_5 = { error: e_5_1 };
          } finally {
            try {
              if (fsPromisesMethods_1_1 && !fsPromisesMethods_1_1.done && (_c = fsPromisesMethods_1.return)) _c.call(fsPromisesMethods_1);
            } finally {
              if (e_5) throw e_5.error;
            }
          }
          try {
            for (var _e = __values(SPECIAL_METHODS.values()), _f = _e.next(); !_f.done; _f = _e.next()) {
              var method = _f.value;
              this[method] = this[method].bind(this);
            }
          } catch (e_6_1) {
            e_6 = { error: e_6_1 };
          } finally {
            try {
              if (_f && !_f.done && (_d = _e.return)) _d.call(_e);
            } finally {
              if (e_6) throw e_6.error;
            }
          }
        }
        Union2.prototype.use = function(fs) {
          this.fss.push(fs);
          return this;
        };
        Union2.prototype.syncMethod = function(method, args) {
          var lastError = null;
          for (var i = this.fss.length - 1; i >= 0; i--) {
            var fs = this.fss[i];
            try {
              if (!fs[method])
                throw Error('Method not supported: "'.concat(method, '" with args "').concat(args, '"'));
              return fs[method].apply(fs, args);
            } catch (err) {
              err.prev = lastError;
              lastError = err;
              if (!i) {
                throw err;
              } else {
              }
            }
          }
        };
        Union2.prototype.asyncMethod = function(method, args) {
          var _this = this;
          var lastarg = args.length - 1;
          var cb = args[lastarg];
          if (typeof cb !== "function") {
            cb = null;
            lastarg++;
          }
          var lastError = null;
          var iterate = function(i, err) {
            if (i === void 0) {
              i = 0;
            }
            if (err) {
              err.prev = lastError;
              lastError = err;
            }
            if (i >= _this.fss.length) {
              if (cb)
                cb(err || Error("No file systems attached."));
              return;
            }
            args[lastarg] = function(err2) {
              if (err2)
                return iterate(i + 1, err2);
              if (cb)
                cb.apply(cb, arguments);
            };
            var j = _this.fss.length - i - 1;
            var fs = _this.fss[j];
            var func = fs[method];
            if (!func)
              iterate(i + 1, Error("Method not supported: " + method));
            else
              func.apply(fs, args);
          };
          iterate();
        };
        Union2.prototype.promiseMethod = function(method, args) {
          return __awaiter(this, void 0, void 0, function() {
            var lastError, i, theFs, promises, err_2;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  lastError = null;
                  i = this.fss.length - 1;
                  _a2.label = 1;
                case 1:
                  if (!(i >= 0)) return [3, 6];
                  theFs = this.fss[i];
                  promises = theFs.promises;
                  _a2.label = 2;
                case 2:
                  _a2.trys.push([2, 4, , 5]);
                  if (!promises || !promises[method]) {
                    throw Error('Promise of method not supported: "'.concat(String(method), '" with args "').concat(args, '"'));
                  }
                  return [4, promises[method].apply(promises, args)];
                case 3:
                  return [2, _a2.sent()];
                case 4:
                  err_2 = _a2.sent();
                  err_2.prev = lastError;
                  lastError = err_2;
                  if (!i) {
                    throw err_2;
                  } else {
                  }
                  return [3, 5];
                case 5:
                  i--;
                  return [3, 1];
                case 6:
                  return [
                    2
                    /*return*/
                  ];
              }
            });
          });
        };
        return Union2;
      }()
    );
    exports2.Union = Union;
  }
});

// ../../node_modules/.pnpm/unionfs@4.5.4/node_modules/unionfs/lib/index.js
var require_lib2 = __commonJS({
  "../../node_modules/.pnpm/unionfs@4.5.4/node_modules/unionfs/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ufs = exports2.Union = void 0;
    var union_1 = require_union();
    exports2.Union = union_1.Union;
    exports2.ufs = new union_1.Union();
    exports2.default = exports2.ufs;
  }
});

// src/typescript-worker.ts
var typescript_worker_exports = {};
module.exports = __toCommonJS(typescript_worker_exports);
var realFS = __toESM(require("fs"));
var import_memfs = __toESM(require_lib());
var import_path2 = __toESM(require("path"));
var import_typescript2 = __toESM(require("typescript"));
var import_unionfs = __toESM(require_lib2());
var import_worker_threads = require("worker_threads");

// src/reporter.ts
var import_path = __toESM(require("path"));
var import_typescript = __toESM(require("typescript"));
var _Reporter = class _Reporter {
  constructor(basedir, postMessage = () => {
  }) {
    this.basedir = basedir;
    this.postMessage = postMessage;
    this.start = Date.now();
    this.reportBuildStart = ({ build = false, watch = false } = {}) => {
      this.postMessage({ type: "start", build, watch });
    };
    this.reportBuildDone = (errorCount) => {
      this.postMessage({ type: "done", errorCount, duration: Date.now() - this.start });
    };
    this.reportDiagnostic = (diagnostic) => {
      this.reportDiagnostics([diagnostic]);
    };
    this.reportDiagnostics = (diagnostics) => {
      this.postMessage({
        type: "diagnostic",
        diagnostics: Array.from(_Reporter.transformDiagnostics(this.basedir, diagnostics)),
        output: _Reporter.getOutput(diagnostics)
      });
    };
    this.reportSummaryDiagnostic = (diagnostic) => {
      switch (diagnostic.code) {
        case 6193:
        // Found 1 error. Watching for file changes.
        case 6194:
          if (typeof diagnostic.messageText === "string") {
            const errorCount = _Reporter.extractErrorCount(diagnostic.messageText);
            this.reportBuildDone(errorCount);
            break;
          }
        case 6032:
          this.reportBuildStart();
          this.markBuildStart();
          break;
        case 6031:
          return;
        // Don't log these
        default:
          this.postMessage({
            type: "summary",
            diagnostics: Array.from(_Reporter.transformDiagnostics(this.basedir, [diagnostic])),
            output: _Reporter.getOutput([diagnostic])
          });
          break;
      }
    };
  }
  markBuildStart() {
    this.start = Date.now();
  }
  static extractErrorCount(msg) {
    const match = /Found (\d+) errors?/.exec(msg);
    return match ? Number(match[1]) : 0;
  }
  static getOutput(diagnostics) {
    return {
      pretty: import_typescript.default.formatDiagnosticsWithColorAndContext(diagnostics, _Reporter.formatHost),
      standard: import_typescript.default.formatDiagnostics(diagnostics, _Reporter.formatHost)
    };
  }
  static *transformDiagnostics(basedir, diagnostics) {
    for (const diagnostic of diagnostics) {
      const type = diagnostic.category === import_typescript.default.DiagnosticCategory.Error ? "error" : diagnostic.category === import_typescript.default.DiagnosticCategory.Warning ? "warning" : void 0;
      if (!type) continue;
      const { file, length, start } = diagnostic;
      const messageText = import_typescript.default.flattenDiagnosticMessageText(diagnostic.messageText, "\n\n");
      if (!file) continue;
      if (start === void 0 || length === void 0) {
        yield {
          type,
          message: {
            id: `TS${diagnostic.code}`,
            detail: diagnostic.relatedInformation,
            location: null,
            notes: [],
            pluginName: "esbuild-plugin-typecheck",
            text: messageText
          }
        };
        continue;
      }
      const { line, character } = import_typescript.default.getLineAndCharacterOfPosition(file, start);
      const lastLineInFile = import_typescript.default.getLineAndCharacterOfPosition(file, file.text.length).line;
      const lineStart = import_typescript.default.getPositionOfLineAndCharacter(file, line, 0);
      const lineEnd = line < lastLineInFile ? import_typescript.default.getPositionOfLineAndCharacter(file, line + 1, 0) : file.text.length;
      const lineText = file.text.slice(lineStart, lineEnd).trimEnd();
      const safeLength = character + length > lineEnd - lineStart ? lineEnd - lineStart - character : length;
      const message = {
        id: `TS${diagnostic.code}`,
        detail: void 0,
        location: {
          column: character,
          file: import_path.default.relative(basedir, file.fileName),
          length: safeLength,
          line,
          lineText,
          namespace: "",
          suggestion: ""
        },
        pluginName: "esbuild-plugin-typecheck",
        notes: [],
        text: messageText
      };
      yield { type, message };
    }
  }
};
_Reporter.formatHost = {
  getCanonicalFileName: (path3) => path3,
  getCurrentDirectory: import_typescript.default.sys.getCurrentDirectory,
  getNewLine: () => import_typescript.default.sys.newLine
};
var Reporter = _Reporter;

// src/typescript-worker.ts
function createPartialMemoryBackedSystem() {
  const unionfs = import_unionfs.ufs.use(import_memfs.fs).use(realFS);
  const system = {
    ...import_typescript2.default.sys,
    createDirectory(path3) {
      import_memfs.fs.mkdirSync(path3);
    },
    deleteFile(path3) {
      if (import_memfs.fs.existsSync(path3)) import_memfs.fs.unlinkSync(path3);
    },
    directoryExists(path3) {
      return unionfs.existsSync(path3);
    },
    fileExists(path3) {
      return unionfs.existsSync(path3);
    },
    getDirectories(path3) {
      return unionfs.readdirSync(path3, { encoding: "utf-8", withFileTypes: false });
    },
    getModifiedTime(path3) {
      if (!unionfs.existsSync(path3)) return void 0;
      const stat = unionfs.statSync(path3);
      return stat.mtime;
    },
    getFileSize(path3) {
      if (!unionfs.existsSync(path3)) return 0;
      const stat = unionfs.statSync(path3);
      return stat.size;
    },
    readFile(path3, encoding = "utf-8") {
      if (!unionfs.existsSync(path3)) return void 0;
      return unionfs.readFileSync(path3, { encoding });
    },
    setModifiedTime(path3, time) {
      import_memfs.fs.utimesSync(path3, time, time);
    },
    writeFile(path3, data, writeBOM) {
      import_memfs.fs.mkdirpSync((0, import_path2.dirname)(path3));
      import_memfs.fs.writeFileSync(path3, writeBOM ? "\uFEFF" + data : data);
    }
  };
  return system;
}
function createBuilder(configFile, buildOptions, buildMode, reporter) {
  const system = buildMode === "readonly" ? createPartialMemoryBackedSystem() : import_typescript2.default.sys;
  const builderHost = import_typescript2.default.createSolutionBuilderHost(
    system,
    import_typescript2.default.createSemanticDiagnosticsBuilderProgram,
    reporter.reportDiagnostic,
    reporter.reportSummaryDiagnostic,
    reporter.reportBuildDone
  );
  const builder = import_typescript2.default.createSolutionBuilder(builderHost, [configFile], buildOptions);
  return [builder, system];
}
function createWatchBuilder(configFile, buildOptions, buildMode, reporter) {
  const system = buildMode === "readonly" ? createPartialMemoryBackedSystem() : import_typescript2.default.sys;
  const builderHost = import_typescript2.default.createSolutionBuilderWithWatchHost(
    system,
    import_typescript2.default.createSemanticDiagnosticsBuilderProgram,
    reporter.reportDiagnostic,
    reporter.reportSummaryDiagnostic,
    reporter.reportSummaryDiagnostic
  );
  const builder = import_typescript2.default.createSolutionBuilderWithWatch(
    builderHost,
    [configFile],
    {
      incremental: true,
      ...buildOptions
    },
    { excludeDirectories: ["node_modules"] }
  );
  return [builder, system];
}
function runCompiler(commandLine, host, reporter, oldProgram) {
  const { options: compilerOptions, fileNames, errors, projectReferences } = commandLine;
  const program = import_typescript2.default.createEmitAndSemanticDiagnosticsBuilderProgram(
    fileNames,
    compilerOptions,
    host,
    oldProgram,
    errors,
    projectReferences
  );
  const diagnostics = [
    ...program.getConfigFileParsingDiagnostics(),
    ...program.getSyntacticDiagnostics(),
    ...program.getOptionsDiagnostics(),
    ...program.getSemanticDiagnostics()
  ];
  reporter.reportDiagnostics(diagnostics);
  const errorCount = diagnostics.filter((d) => d.category === import_typescript2.default.DiagnosticCategory.Error).length;
  reporter.reportBuildDone(errorCount);
  return program;
}
function startWorker(options, port) {
  const {
    basedir,
    buildMode = "readonly",
    configFile = import_typescript2.default.findConfigFile(basedir, import_typescript2.default.sys.fileExists, "tsconfig.json"),
    watch
  } = options;
  if (!configFile) {
    throw new Error(`Could not find a valid "tsconfig.json" (searching in "${basedir}").`);
  }
  const { config } = import_typescript2.default.readConfigFile(configFile, import_typescript2.default.sys.readFile);
  config.compilerOptions = { ...config.compilerOptions, ...options.compilerOptions };
  const commandLine = import_typescript2.default.parseJsonConfigFileContent(config, import_typescript2.default.sys, import_path2.default.dirname(configFile));
  const build = options.build ?? commandLine.options.composite ?? false;
  const { options: compilerOptions } = commandLine;
  if (compilerOptions.noEmit === void 0) compilerOptions.noEmit = true;
  const reporter = new Reporter(basedir, (msg) => port.postMessage(msg));
  const listen = watch ? port.on.bind(port) : port.once.bind(port);
  if (build) {
    const buildOptions = typeof build === "boolean" ? {} : build;
    const [builder, system] = watch ? createWatchBuilder(configFile, buildOptions, buildMode, reporter) : createBuilder(configFile, buildOptions, buildMode, reporter);
    let firstRun = true;
    listen("message", (msg) => {
      if (msg.type === "build") {
        if (firstRun) {
          reporter.reportBuildStart();
          firstRun = false;
        }
        reporter.markBuildStart();
        builder.build(configFile, void 0, system.writeFile);
      }
    });
  } else {
    let builderProgram;
    const compilerHost = import_typescript2.default.createIncrementalCompilerHost(compilerOptions, import_typescript2.default.sys);
    listen("message", (msg) => {
      if (msg.type === "build") {
        reporter.reportBuildStart();
        reporter.markBuildStart();
        builderProgram = runCompiler(commandLine, compilerHost, reporter, builderProgram);
      }
    });
  }
}
if (!import_worker_threads.isMainThread && import_worker_threads.parentPort) {
  const workerOptions = import_worker_threads.workerData;
  if (!(workerOptions == null ? void 0 : workerOptions.basedir)) {
    throw new Error(
      `compiler-builder (worker) expected valid builder options as workerData, got "${JSON.stringify(
        import_worker_threads.workerData
      )}"`
    );
  }
  startWorker(workerOptions, import_worker_threads.parentPort);
}
//# sourceMappingURL=typescript-worker.js.map
